<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»‘é¾™æ±Ÿå¤§æ¡¥ç›‘æµ‹ç³»ç»Ÿ</title>
    <!-- æ·»åŠ ç½‘é¡µå›¾æ ‡ -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ‰</text></svg>">
    <!-- å¼•å…¥Chart.jsåº“ç”¨äºæ•°æ®å¯è§†åŒ– -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.0/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- å¼•å…¥Material Iconsåº“ -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        body {
            font-family: "Microsoft YaHei", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f9fc;
            color: #333;
        }
        .header {
            background: linear-gradient(135deg, #2c5282, #1a365d);
            color: white;
            padding: 20px 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        .header-subtitle {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }
        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #2c5282;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .logout-btn {
            background-color: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .logout-btn:hover {
            background-color: rgba(255,255,255,0.3);
        }
        /* ç™»å½•æ¨¡æ€æ¡†æ ·å¼ */
        .login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .login-container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            width: 350px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        .login-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .login-header h2 {
            color: #007aff;
            margin: 0;
        }
        .login-form .form-group {
            margin-bottom: 20px;
        }
        .login-form label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .login-form input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .login-form .login-button {
            background-color: #007aff;
            color: white;
            padding: 12px;
            border: none;
            border-radius: 4px;
            width: 100%;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .login-form .login-button:hover {
            background-color: #0056b3;
        }
        .error-message {
            color: #dc3545;
            margin-top: 10px;
            text-align: center;
        }
        /* æ¡¥æ¢ç¤ºæ„å›¾æ ·å¼ */
        .bridge-container {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
            position: relative;
            height: 300px;
            overflow: hidden;
        }
        .bridge {
            position: relative;
            height: 100%;
            width: 100%;
        }
        .bridge-deck {
            position: absolute;
            bottom: 120px;
            left: 5%;
            width: 90%;
            height: 20px;
            background-color: #6c757d;
        }
        .bridge-pier {
            position: absolute;
            bottom: 0;
            width: 40px;
            height: 120px;
            background-color: #495057;
        }
        .bridge-pier:nth-child(1) {
            left: 10%;
        }
        .bridge-pier:nth-child(2) {
            left: 50%;
            transform: translateX(-50%);
        }
        .bridge-pier:nth-child(3) {
            right: 10%;
        }
        .sensor-point {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: #28a745;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            transition: all 0.3s;
            cursor: pointer;
        }
        .sensor-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
            z-index: 10;
        }
        .sensor-point.warning {
            background-color: #ffc107;
        }
        .sensor-point.danger {
            background-color: #dc3545;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        .sensor-tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            padding: 24px;
            margin-bottom: 24px;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid rgba(0,0,0,0.03);
        }
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
        }
        .card-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 18px;
            color: #2c5282;
            border-bottom: 1px solid #edf2f7;
            padding-bottom: 12px;
            display: flex;
            align-items: center;
        }
        .card-title::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 18px;
            background-color: #2c5282;
            margin-right: 10px;
            border-radius: 2px;
        }
        .example-file-link {
            margin-top: 12px;
            display: block;
            font-size: 14px;
            color: #2c5282;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 6px;
            background-color: #edf2f7;
            transition: all 0.2s;
            width: fit-content;
        }
        .example-file-link:hover {
            background-color: #e2e8f0;
            text-decoration: none;
            transform: translateY(-2px);
        }
        .file-format-info {
            background-color: #f8fafc;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            font-size: 13px;
            border-left: 3px solid #2c5282;
        }
        .upload-area {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .file-input-container {
            position: relative;
            margin-right: 15px;
            margin-bottom: 10px;
        }
        .custom-file-input {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
        }
        .custom-file-input:hover {
            background-color: #e0e0e0;
        }
        #fileInput {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .button {
            background-color: #2c5282;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: all 0.2s;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }
        .button:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.12);
        }
        .button:active {
            transform: translateY(0);
        }
        .button.secondary {
            background-color: #718096;
        }
        .button.secondary:hover {
            background-color: #4a5568;
        }
        .button.danger {
            background-color: #e53e3e;
        }
        .button.danger:hover {
            background-color: #c53030;
        }
        .button .material-icons {
            font-size: 16px;
            margin-right: 6px;
        }
        .button:disabled {
            background-color: #cbd5e0;
            color: #718096;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .data-table-container {
            overflow-x: auto;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .data-table th, .data-table td {
            border: 1px solid #edf2f7;
            padding: 10px 14px;
            text-align: left;
        }
        .data-table th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #4a5568;
        }
        .data-table tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .data-table tr:hover {
            background-color: #ebf4ff;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 20px;
        }
        .result-area {
            margin-top: 30px;
        }
        .anomaly-list {
            list-style-type: none;
            padding: 0;
        }
        .anomaly-item {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .anomaly-item.severe {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            color: white;
            margin-right: 5px;
        }
        .status-normal {
            background-color: #28a745;
        }
        .status-warning {
            background-color: #ffc107;
            color: #212529;
        }
        .status-danger {
            background-color: #dc3545;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 24px;
            background-color: white;
            border-radius: 8px 8px 0 0;
            padding: 0 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .tab {
            padding: 16px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            color: #4a5568;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
        }
        .tab:hover {
            color: #2c5282;
        }
        .tab.active {
            border-bottom-color: #2c5282;
            color: #2c5282;
            font-weight: 600;
        }
        .tab.active::after {
            content: "";
            position: absolute;
            bottom: -3px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background-color: #2c5282;
            border-radius: 50%;
        }
        .tab-content {
            display: none;
            background-color: white;
            border-radius: 0 0 8px 8px;
            padding: 10px 0;
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .tab-content.active {
            display: block;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #007aff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .analysis-summary {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .info-text {
            color: #6c757d;
            font-size: 14px;
            margin: 10px 0;
        }
        .anomaly-count {
            font-size: 24px;
            font-weight: bold;
            color: #dc3545;
            margin-right: 5px;
        }
        .no-data-message {
            text-align: center;
            padding: 30px;
            color: #6c757d;
        }
        .camera-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .camera-item {
            width: calc(25% - 15px);
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 5px;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .camera-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .camera-name {
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .camera-status {
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
        }
        .sensor-id {
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 4px;
            display: inline-block;
        }
        .online {
            background-color: #28a745;
            color: white;
        }
        .offline {
            background-color: #dc3545;
            color: white;
        }
        .warning {
            background-color: #ffc107;
            color: #212529;
        }
        .camera-view {
            position: relative;
            height: 160px;
            background-color: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
        }
        .camera-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
        }
        .camera-icon {
            font-size: 36px;
            margin-bottom: 10px;
            color: #6c757d;
        }
        .camera-message {
            font-size: 12px;
            text-align: center;
            padding: 0 10px;
        }
        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .camera-view:hover .camera-overlay {
            opacity: 1;
        }
        .camera-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
        }
        .camera-control-btn {
            background-color: rgba(255,255,255,0.8);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            margin: 0 2px;
            font-size: 12px;
        }
        .camera-control-btn:hover {
            background-color: rgba(255,255,255,1);
        }
        .camera-info {
            margin-top: 20px;
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .camera-alert {
            color: #007aff;
            font-size: 14px;
            margin-top: 10px;
        }
        .location-tag {
            font-size: 11px;
            color: #6c757d;
            margin-top: 4px;
            margin-bottom: 5px;
            display: block;
        }
        /* åˆ—è¡¨è§†å›¾æ ·å¼ */
        .camera-list {
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        .camera-list-item {
            display: flex;
            align-items: center;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 10px 15px;
        }
        .camera-list-icon {
            width: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 15px;
            font-size: 24px;
        }
        .camera-list-info {
            flex-grow: 1;
        }
        .camera-list-actions {
            display: flex;
            gap: 10px;
        }
        .event-status-display {
            padding: 10px 0;
        }
        .event-status-header {
            display: flex;
            align-items: center;
            font-weight: 600;
            color: #2c5282;
            margin-bottom: 10px;
        }
        .event-details {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #2c5282;
            transition: all 0.3s ease;
        }
        #currentEventName {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 5px;
        }
        #currentEventDescription {
            color: #4a5568;
            margin-bottom: 10px;
        }
        .event-progress-container {
            margin-top: 10px;
        }
        .event-progress-bar {
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .event-progress {
            height: 100%;
            background-color: #2c5282;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .event-progress-text {
            text-align: right;
            font-size: 12px;
            color: #718096;
        }
        .event-alert {
            background-color: #fed7d7;
            border-left: 3px solid #e53e3e;
        }
        .event-alert #currentEventName {
            color: #c53030;
        }
        .event-alert .event-progress {
            background-color: #e53e3e;
        }
        .event-warning {
            background-color: #feebc8;
            border-left: 3px solid #dd6b20;
        }
        .event-warning #currentEventName {
            color: #c05621;
        }
        .event-warning .event-progress {
            background-color: #dd6b20;
        }
        .event-controls {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8fafc;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .event-controls h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2d3748;
            font-size: 16px;
        }
        .event-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .event-buttons button {
            padding: 6px 12px;
            background-color: #edf2f7;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .event-buttons button:hover {
            background-color: #e2e8f0;
        }
        .event-buttons button.active {
            background-color: #4299e1;
            color: white;
            border-color: #3182ce;
        }
        .chart-control-btn {
            transition: all 0.2s ease;
        }
        .chart-control-btn:hover {
            opacity: 0.9;
        }
        .chart-control-btn.active {
            background-color: #4299e1 !important;
            color: white !important;
            border-color: #3182ce !important;
        }
        /* äº‹ä»¶çŠ¶æ€æ˜¾ç¤ºæ ·å¼ */
        .event-status-display {
            padding: 10px 0;
        }
        .event-status-header {
            display: flex;
            align-items: center;
            font-weight: 600;
            color: #2c5282;
            margin-bottom: 10px;
        }
        .event-details {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #2c5282;
            transition: all 0.3s ease;
        }
        #currentEventName {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 5px;
        }
        #currentEventDescription {
            color: #4a5568;
            margin-bottom: 10px;
        }
        .event-progress-container {
            margin-top: 10px;
        }
        .event-progress-bar {
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .event-progress {
            height: 100%;
            background-color: #2c5282;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .event-progress-text {
            text-align: right;
            font-size: 12px;
            color: #718096;
        }
        .event-alert {
            background-color: #fed7d7;
            border-left: 3px solid #e53e3e;
        }
        .event-alert #currentEventName {
            color: #c53030;
        }
        .event-alert .event-progress {
            background-color: #e53e3e;
        }
        .event-warning {
            background-color: #feebc8;
            border-left: 3px solid #dd6b20;
        }
        .event-warning #currentEventName {
            color: #c05621;
        }
        .event-warning .event-progress {
            background-color: #dd6b20;
        }
        .event-controls {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8fafc;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .event-controls h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2d3748;
            font-size: 16px;
        }
        .event-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .event-buttons button {
            padding: 6px 12px;
            background-color: #edf2f7;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .event-buttons button:hover {
            background-color: #e2e8f0;
        }
        .event-buttons button.active {
            background-color: #4299e1;
            color: white;
            border-color: #3182ce;
        }
        /* å†å²è®°å½•åŒºåŸŸæ ·å¼ */
        .history-section {
            margin-bottom: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 15px;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .history-header h3 {
            margin: 0;
            font-size: 16px;
            color: #2d3748;
        }
        .history-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .history-item {
            padding: 10px;
            border-left: 3px solid #4299e1;
            background-color: #f8fafc;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .history-item:hover {
            background-color: #edf2f7;
        }
        .history-item-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .history-item-title {
            font-weight: 500;
        }
        .history-item-time {
            font-size: 12px;
            color: #718096;
        }
        .history-item-stats {
            font-size: 13px;
            color: #4a5568;
        }
        .no-history-message {
            text-align: center;
            padding: 20px;
            color: #a0aec0;
        }
        .button.small {
            padding: 6px 12px;
            font-size: 12px;
        }
        /* æ·»åŠ æ–°çš„CSSæ ·å¼ */
        .event-prediction-area {
            margin-bottom: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }
        .event-prediction-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .event-prediction-header .material-icons {
            margin-right: 10px;
            color: #e53e3e;
        }
        .event-prediction-header h3 {
            margin: 0;
            color: #2d3748;
            font-size: 18px;
        }
        .prediction-item {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-left: 4px solid #718096;
        }
        .prediction-item.high {
            border-left-color: #e53e3e;
        }
        .prediction-item.medium {
            border-left-color: #dd6b20;
        }
        .prediction-item.low {
            border-left-color: #3182ce;
        }
        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .prediction-type {
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            color: #2d3748;
        }
        .prediction-type .material-icons {
            margin-right: 8px;
        }
        .prediction-probability {
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 14px;
            color: white;
        }
        .prediction-probability.high {
            background-color: #e53e3e;
        }
        .prediction-probability.medium {
            background-color: #dd6b20;
        }
        .prediction-probability.low {
            background-color: #3182ce;
        }
        .prediction-details {
            margin-bottom: 10px;
        }
        .prediction-reasoning {
            font-size: 14px;
            color: #4a5568;
            margin-bottom: 5px;
        }
        .prediction-timestamp {
            font-size: 12px;
            color: #718096;
        }
        .prediction-sensors {
            font-size: 13px;
            color: #4a5568;
            background-color: #f7fafc;
            padding: 5px 10px;
            border-radius: 4px;
        }
        .no-prediction-message {
            text-align: center;
            padding: 20px;
            color: #718096;
            font-style: italic;
        }
        .search-filter-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .search-box {
            position: relative;
            width: 300px;
        }
        .search-box input {
            width: 100%;
            padding: 10px 15px 10px 35px;
            border: 1px solid #e2e8f0;
            border-radius: 20px;
            font-size: 14px;
        }
        .search-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #a0aec0;
        }
        .filter-controls {
            display: flex;
            gap: 10px;
        }
        .filter-controls select {
            padding: 8px 15px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            background-color: white;
        }
        .camera-last-update {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }
        .no-cameras-message {
            text-align: center;
            padding: 30px;
            color: #718096;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>é»‘é¾™æ±Ÿå¤§æ¡¥ç›‘æµ‹ç³»ç»Ÿ</h1>
        <div class="header-subtitle">æ¡¥æ¢ç»“æ„å¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ</div>
        <div class="user-info" id="userInfoDisplay" style="display:none;">
            <div class="user-avatar" id="userAvatar">U</div>
            <span id="userName">ç”¨æˆ·</span>
            <button class="logout-btn" id="logoutButton">é€€å‡º</button>
        </div>
    </div>

    <!-- äº‹ä»¶é¢„æµ‹åŒºåŸŸ - ç§»åˆ°é¡¶éƒ¨ -->
    <div class="container">
        <div class="event-prediction-area">
            <div class="event-prediction-header">
                <span class="material-icons">warning</span>
                <h3>äº‹ä»¶é¢„æµ‹</h3>
            </div>
            <div class="event-prediction-content" id="eventPredictionContent">
                <div class="no-prediction-message">
                    ç³»ç»Ÿæ­£åœ¨å®æ—¶åˆ†æä¼ æ„Ÿå™¨æ•°æ®ï¼Œæš‚æ— å¼‚å¸¸äº‹ä»¶é¢„æµ‹
                </div>
                <!-- äº‹ä»¶é¢„æµ‹é¡¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <!-- ç™»å½•æ¨¡æ€æ¡† -->
    <div class="login-modal" id="loginModal">
        <div class="login-container">
            <div class="login-header">
                <h2>ç³»ç»Ÿç™»å½•</h2>
            </div>
            <div class="login-form">
                <div class="form-group">
                    <label for="username">ç”¨æˆ·å</label>
                    <input type="text" id="username" placeholder="è¯·è¾“å…¥ç”¨æˆ·å">
                </div>
                <div class="form-group">
                    <label for="password">å¯†ç </label>
                    <input type="password" id="password" placeholder="è¯·è¾“å…¥å¯†ç ">
                </div>
                <button class="login-button" id="loginButton">ç™»å½•</button>
                <div class="error-message" id="loginError"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="card">
            <div class="card-title">æ•°æ®ä¸Šä¼ ä¸åˆ†æ</div>
            <div class="upload-area">
                <div class="file-input-container">
                    <div class="custom-file-input">
                        <span class="material-icons">cloud_upload</span>
                        é€‰æ‹©æ–‡ä»¶
                    </div>
                    <input type="file" id="fileInput" accept=".txt,.csv">
                </div>
                <button class="button" id="uploadButton">
                    <span class="material-icons">publish</span>
                    ä¸Šä¼ æ•°æ®
                </button>
                <button class="button secondary" id="resetButton">
                    <span class="material-icons">restart_alt</span>
                    é‡ç½®
                </button>
                <button class="button" id="detectButton" disabled>
                    <span class="material-icons">search</span>
                    å¼€å§‹æ£€æµ‹
                </button>
                <button class="button secondary" id="sampleButton">
                    <span class="material-icons">data_object</span>
                    ç”Ÿæˆç¤ºä¾‹æ•°æ®
                </button>
                <button class="button secondary" id="refreshButton">
                    <span class="material-icons">autorenew</span>
                    éšæœºåˆ·æ–°æ•°æ®
                </button>
            </div>
            <div class="info-text" id="fileInfo">æœªé€‰æ‹©æ–‡ä»¶</div>
            <a href="#" id="downloadExample" class="example-file-link">
                <span class="material-icons" style="font-size:16px;vertical-align:middle;">file_download</span> 
                ä¸‹è½½æ•°æ®æ ¼å¼ç¤ºä¾‹æ–‡ä»¶
            </a>
            <div class="file-format-info">
                <strong>æ”¯æŒçš„æ–‡ä»¶æ ¼å¼:</strong>
                <ul style="margin-top: 5px; margin-bottom: 5px;">
                    <li>CSVæ ¼å¼: æ—¶é—´æˆ³,ä¼ æ„Ÿå™¨ID,æ•°å€¼ (æ¯è¡Œä¸€æ¡è®°å½•)</li>
                    <li>TXTæ ¼å¼: æ—¶é—´æˆ³,æ•°å€¼ (æ¯è¡Œä¸€æ¡è®°å½•ï¼Œè‡ªåŠ¨åˆ†é…ä¼ æ„Ÿå™¨ID)</li>
                </ul>
                <div>ç¤ºä¾‹: 2023-06-15 14:30,ä¼ æ„Ÿå™¨A,23.45</div>
            </div>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="data">
                <span class="material-icons" style="margin-right:8px;">table_chart</span>
                æ•°æ®æŸ¥çœ‹
            </div>
            <div class="tab" data-tab="visualization">
                <span class="material-icons" style="margin-right:8px;">bar_chart</span>
                æ•°æ®å¯è§†åŒ–
            </div>
            <div class="tab" data-tab="analysis">
                <span class="material-icons" style="margin-right:8px;">analytics</span>
                å¼‚å¸¸æ£€æµ‹ç»“æœ
            </div>
            <div class="tab" data-tab="monitor">
                <span class="material-icons" style="margin-right:8px;">videocam</span>
                å¼‚å¸¸ç›‘æ§
            </div>
        </div>

        <div class="tab-content active" id="data-tab">
            <div class="card">
                <div class="card-title">ä¼ æ„Ÿå™¨æ•°æ®</div>
                <div class="data-table-container">
                    <table class="data-table" id="dataTable">
                        <thead>
                            <tr>
                                <th>æ—¶é—´æˆ³</th>
                                <th>ä¼ æ„Ÿå™¨ID</th>
                                <th>æ•°å€¼</th>
                                <th>çŠ¶æ€</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- æ•°æ®è¡Œå°†åŠ¨æ€æ’å…¥ -->
                        </tbody>
                    </table>
                </div>
                <div class="no-data-message" id="noDataMessage">
                    è¯·ä¸Šä¼ æ•°æ®æ–‡ä»¶å¼€å§‹åˆ†æ
                </div>
            </div>
        </div>

        <div class="tab-content" id="visualization-tab">
            <div class="card">
                <div class="card-title">ä¼ æ„Ÿå™¨æ•°æ®å¯è§†åŒ–</div>
                <div class="chart-container">
                    <canvas id="dataChart"></canvas>
                </div>
                <div class="no-data-message" id="noChartDataMessage">
                    è¯·ä¸Šä¼ æ•°æ®æ–‡ä»¶æŸ¥çœ‹å¯è§†åŒ–å›¾è¡¨
                </div>
            </div>
        </div>

        <div class="tab-content" id="analysis-tab">
            <div class="card">
                <div class="card-title">å¼‚å¸¸æ£€æµ‹ç»“æœ</div>
                <!-- å†å²è®°å½•åŒºåŸŸ -->
                <div class="history-section">
                    <div class="history-header">
                        <h3>å†å²æ£€æµ‹è®°å½•</h3>
                        <button id="clearHistoryBtn" class="button secondary small">
                            <span class="material-icons">delete</span>
                            æ¸…ç©ºå†å²
                        </button>
                    </div>
                    <div class="history-list" id="detectionHistory">
                        <!-- å†å²è®°å½•é¡¹å°†åœ¨è¿™é‡ŒåŠ¨æ€æ·»åŠ  -->
                        <div class="no-history-message">æš‚æ— å†å²è®°å½•</div>
                    </div>
                </div>
                <div class="loader" id="analysisLoader"></div>
                <div class="analysis-summary" id="analysisSummary" style="display:none;">
                    <h3>æ•°æ®åˆ†ææ‘˜è¦</h3>
                    <p>æ€»æ•°æ®ç‚¹: <span id="totalPoints">0</span></p>
                    <p>æ£€æµ‹åˆ° <span class="anomaly-count" id="anomalyCount">0</span> ä¸ªå¼‚å¸¸</p>
                    <p>å¼‚å¸¸ç±»å‹åˆ†å¸ƒ:</p>
                    <ul>
                        <li>å•ç‚¹å¼‚å¸¸: <span id="singlePointCount">0</span></li>
                        <li>è¿ç»­æ€§å¼‚å¸¸: <span id="continuousCount">0</span></li>
                        <li>ç¾¤ä½“å¼‚å¸¸: <span id="clusterCount">0</span></li>
                    </ul>
                </div>
                <div class="chart-container">
                    <canvas id="anomalyChart"></canvas>
                </div>
                <div class="result-area">
                    <h3>è¯¦ç»†å¼‚å¸¸åˆ—è¡¨</h3>
                    <ul class="anomaly-list" id="anomalyList">
                        <!-- å¼‚å¸¸é¡¹å°†åŠ¨æ€æ’å…¥ -->
                    </ul>
                </div>
                <div class="no-data-message" id="noAnalysisMessage">
                    è¯·ç‚¹å‡»"å¼€å§‹æ£€æµ‹"æŒ‰é’®è¿›è¡Œå¼‚å¸¸æ£€æµ‹
                </div>
            </div>
        </div>

        <div class="tab-content" id="monitor-tab">
            <div class="card">
                <div class="card-title">æ¡¥æ¢ç›‘æ§</div>
                
                <!-- æ‘„åƒå¤´æœç´¢å’Œç­›é€‰åŒºåŸŸ -->
                <div class="camera-control-section">
                    <div class="search-filter-row">
                        <div class="search-box">
                            <input type="text" id="camera-search" placeholder="æœç´¢æ‘„åƒå¤´..." aria-label="æœç´¢æ‘„åƒå¤´">
                            <span class="material-icons search-icon">search</span>
                        </div>
                        <div class="filter-controls">
                            <select id="camera-filter" aria-label="æ‘„åƒå¤´ç­›é€‰">
                                <option value="all">å…¨éƒ¨æ‘„åƒå¤´</option>
                                <option value="online">åœ¨çº¿</option>
                                <option value="offline">ç¦»çº¿</option>
                                <option value="warning">å¼‚å¸¸</option>
                            </select>
                            <select id="section-filter" aria-label="åŒºæ®µç­›é€‰">
                                <option value="all">å…¨éƒ¨åŒºæ®µ</option>
                                <option value="north">åŒ—æ®µ</option>
                                <option value="center">ä¸­æ®µ</option>
                                <option value="south">å—æ®µ</option>
                                <option value="east">ä¸œæ®µ</option>
                                <option value="west">è¥¿æ®µ</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- æ‘„åƒå¤´ç½‘æ ¼ -->
                <div class="camera-grid" id="cameraGrid">
                    <!-- æ‘„åƒå¤´å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
                
                <div class="no-data-message" id="noMonitorMessage">
                    è¯·ä¸Šä¼ æ•°æ®æˆ–ç”Ÿæˆç¤ºä¾‹æ•°æ®æ¥å¯ç”¨ç›‘æ§è§†å›¾
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡å£°æ˜åŒºåŸŸ - ä¿ç•™ä¸€ä»½å®šä¹‰ï¼Œåˆ é™¤é‡å¤çš„å£°æ˜
        let sensorData = [];
        let allCameras = [];
        let dataUpdateInterval = null;
        let selectedSensors = [];
        let eventPredictions = [];
        let currentEventSimulation = null;
        let dataChart = null;
        let anomalyChart = null;
        let isLoggedIn = false;
        let currentUser = null;
        let zScores = [];
        let anomalyIndices = [];
        let anomalyTypes = [];
        
        // DOM å…ƒç´ å¼•ç”¨
        const loginModal = document.querySelector('.login-modal');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const loginError = document.querySelector('.error-message');
        const userInfoDisplay = document.querySelector('.user-info');
        const userAvatar = document.querySelector('.user-avatar');
        const usernameDisplay = document.querySelector('.username-display');
        const noDataMessage = document.getElementById('noDataMessage');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const uploadButton = document.getElementById('uploadButton');
        const detectButton = document.getElementById('detectButton');
        const sampleButton = document.getElementById('sampleButton');
        const resetButton = document.getElementById('resetButton');
        const refreshButton = document.getElementById('refreshButton');
        const downloadExample = document.getElementById('downloadExample');
        const sensorTooltip = document.createElement('div');
        const eventNameElement = document.getElementById('eventName');
        const eventDescElement = document.getElementById('eventDescription');
        const eventDetails = document.querySelector('.event-details');
        const eventProgressContainer = document.querySelector('.event-progress-container');
        const eventProgressBar = document.querySelector('.event-progress-bar');
        const cameraContainer = document.getElementById('camera-container');
        const dataTable = document.getElementById('dataTable');
        const noChartDataMessage = document.getElementById('noChartDataMessage');
        const noAnalysisMessage = document.getElementById('noAnalysisMessage');
        const noMonitorMessage = document.getElementById('noMonitorMessage');
        const analysisLoader = document.getElementById('analysisLoader');
        const analysisSummary = document.getElementById('analysisSummary');
        const anomalyList = document.getElementById('anomalyList');
        const totalPoints = document.getElementById('totalPoints');
        const anomalyCount = document.getElementById('anomalyCount');
        const singlePointCount = document.getElementById('singlePointCount');
        const continuousCount = document.getElementById('continuousCount');
        const clusterCount = document.getElementById('clusterCount');
        const userName = document.getElementById('userName');
        const logoutButton = document.getElementById('logoutButton');
        
        // ä¼ æ„Ÿå™¨èŒƒå›´
        const sensorRanges = {
            'æ¸©åº¦': {
                normal: [15, 35],
                warning: [10, 40],
                danger: [5, 45]
            },
            'åº”å˜': {
                normal: [100, 300],
                warning: [80, 350],
                danger: [50, 400]
            },
            'æŒ¯åŠ¨': {
                normal: [0.1, 1.0],
                warning: [0.05, 1.5],
                danger: [0, 2.0]
            },
            'å€¾è§’': {
                normal: [0, 1.0],
                warning: [-0.5, 1.5],
                danger: [-1.0, 2.0]
            },
            'å…¶ä»–': {
                normal: [50, 150],
                warning: [30, 170],
                danger: [10, 190]
            }
        };
        
        // å…¨å±€å˜é‡ - äº‹ä»¶æ¨¡æ‹Ÿç±»å‹
        const bridgeEvents = {
            NORMAL: 'normal',
            EARTHQUAKE: 'earthquake',
            STRONG_WIND: 'strong_wind',
            HEAVY_TRAFFIC: 'heavy_traffic',
            TEMPERATURE_CHANGE: 'temperature_change',
            FLOOD: 'flood'
        };

        // å„ç±»äº‹ä»¶çš„è®¾ç½®
        const eventSettings = {
            [bridgeEvents.NORMAL]: {
                name: "æ­£å¸¸è¿è¡Œ",
                description: "æ¡¥æ¢ç»“æ„æ­£å¸¸ï¼Œæ‰€æœ‰ç›‘æµ‹å‚æ•°åœ¨å®‰å…¨èŒƒå›´å†…ã€‚",
                duration: [0, 0], // æ— æŒç»­æ—¶é—´
                severity: 'normal',
                icon: 'ğŸŸ¢'
            },
            [bridgeEvents.EARTHQUAKE]: {
                name: "åœ°éœ‡äº‹ä»¶",
                description: "æ£€æµ‹åˆ°åœ°éœ‡æ´»åŠ¨ï¼ŒæŒ¯åŠ¨ä¼ æ„Ÿå™¨æ˜¾ç¤ºå¼‚å¸¸è¯»æ•°ï¼Œå»ºè®®è¿›è¡Œå®‰å…¨æ£€æŸ¥ã€‚",
                duration: [10, 20], // æŒç»­10-20ä¸ªå‘¨æœŸ
                severity: 'alert',
                icon: 'ğŸ”´'
            },
            [bridgeEvents.STRONG_WIND]: {
                name: "å¼ºé£äº‹ä»¶",
                description: "å½“å‰é£é€Ÿè¿‡é«˜ï¼Œæ¡¥æ¢ç»“æ„æ‰¿å—è¾ƒå¤§é£è½½è·ï¼Œå»ºè®®é™é€Ÿé€šè¡Œã€‚",
                duration: [15, 30], // æŒç»­15-30ä¸ªå‘¨æœŸ
                severity: 'warning',
                icon: 'ğŸŸ '
            },
            [bridgeEvents.HEAVY_TRAFFIC]: {
                name: "äº¤é€šæ‹¥å µ",
                description: "æ¡¥é¢äº¤é€šæµé‡è¿‡å¤§ï¼Œæ¡¥æ¢æ‰¿å—é¢å¤–è½½è·ï¼Œåº”å˜ä¼ æ„Ÿå™¨è¯»æ•°å‡é«˜ã€‚",
                duration: [20, 40], // æŒç»­20-40ä¸ªå‘¨æœŸ
                severity: 'warning',
                icon: 'ğŸŸ '
            },
            [bridgeEvents.TEMPERATURE_CHANGE]: {
                name: "æ¸©åº¦å‰§å˜",
                description: "æ£€æµ‹åˆ°ç¯å¢ƒæ¸©åº¦å¿«é€Ÿå˜åŒ–ï¼Œææ–™çƒ­èƒ€å†·ç¼©å¯¼è‡´åº”å˜å˜åŒ–ã€‚",
                duration: [25, 45], // æŒç»­25-45ä¸ªå‘¨æœŸ
                severity: 'warning',
                icon: 'ğŸŸ '
            },
            [bridgeEvents.FLOOD]: {
                name: "æ´ªæ°´è­¦æŠ¥",
                description: "æ£€æµ‹åˆ°æ°´ä½å¼‚å¸¸ä¸Šæ¶¨ï¼Œæ¡¥å¢©å—åˆ°æ°´æµå†²å‡»ï¼ŒæŒ¯åŠ¨å’Œå€¾è§’ä¼ æ„Ÿå™¨æ•°æ®å¼‚å¸¸ã€‚",
                duration: [30, 60], // æŒç»­30-60ä¸ªå‘¨æœŸ
                severity: 'alert',
                icon: 'ğŸ”´'
            }
        };

        // ç™»å½•åŠŸèƒ½
        function checkLoginStatus() {
            console.log("æ£€æŸ¥ç™»å½•çŠ¶æ€...");
            // ä»localStorageæ£€æŸ¥ç™»å½•çŠ¶æ€
            const storedUser = localStorage.getItem('bridgeSystemUser');
            if (storedUser) {
                try {
                    currentUser = JSON.parse(storedUser);
                    isLoggedIn = true;
                    showUserInfo();
                    hideLoginModal();
                    console.log("ç”¨æˆ·å·²ç™»å½•:", currentUser.username);
                } catch (e) {
                    console.error('è§£æå­˜å‚¨çš„ç”¨æˆ·ä¿¡æ¯æ—¶å‡ºé”™:', e);
                    showLoginModal();
                }
            } else {
                console.log("æœªæ‰¾åˆ°ç™»å½•ä¿¡æ¯ï¼Œæ˜¾ç¤ºç™»å½•ç•Œé¢");
                showLoginModal();
            }
        }

        function showUserInfo() {
            console.log("æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯");
            if (currentUser && userInfoDisplay) {
                userInfoDisplay.style.display = 'flex';
                if (userName) userName.textContent = currentUser.username;
                if (userAvatar) userAvatar.textContent = currentUser.username.charAt(0).toUpperCase();
            } else {
                console.warn("æ— æ³•æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯ï¼Œæ£€æŸ¥userInfoDisplayæˆ–currentUseræ˜¯å¦å­˜åœ¨");
            }
        }

        function hideUserInfo() {
            if (userInfoDisplay) {
                userInfoDisplay.style.display = 'none';
            }
        }

        function showLoginModal() {
            console.log("æ˜¾ç¤ºç™»å½•ç•Œé¢");
            if (loginModal) {
                loginModal.style.display = 'flex';
                if (usernameInput) usernameInput.focus();
            } else {
                console.error("ç™»å½•æ¨¡æ€æ¡†ä¸å­˜åœ¨ï¼Œæ£€æŸ¥HTMLç»“æ„");
                // å¦‚æœæ‰¾ä¸åˆ°æ¨¡æ€æ¡†ï¼Œåˆ›å»ºä¸€ä¸ªä¸´æ—¶ç™»å½•ç•Œé¢
                createTemporaryLoginForm();
            }
        }

        function createTemporaryLoginForm() {
            console.log("åˆ›å»ºä¸´æ—¶ç™»å½•è¡¨å•");
            // åˆ›å»ºä¸´æ—¶ç™»å½•è¡¨å•ï¼Œä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
            const tempLoginForm = document.createElement('div');
            tempLoginForm.id = 'tempLoginForm';
            tempLoginForm.className = 'login-modal';
            tempLoginForm.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); display:flex; justify-content:center; align-items:center; z-index:9999;';
            
            tempLoginForm.innerHTML = `
                <div class="login-container" style="background:white; padding:20px; border-radius:8px; width:300px; box-shadow:0 0 10px rgba(0,0,0,0.2);">
                    <h2 style="text-align:center; margin-bottom:20px;">é»‘é¾™æ±Ÿå¤§æ¡¥ç›‘æµ‹ç³»ç»Ÿ</h2>
                    <div style="margin-bottom:15px;">
                        <label for="temp-username" style="display:block; margin-bottom:5px;">ç”¨æˆ·å</label>
                        <input type="text" id="temp-username" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" placeholder="è¯·è¾“å…¥ç”¨æˆ·å">
                    </div>
                    <div style="margin-bottom:15px;">
                        <label for="temp-password" style="display:block; margin-bottom:5px;">å¯†ç </label>
                        <input type="password" id="temp-password" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" placeholder="è¯·è¾“å…¥å¯†ç ">
                    </div>
                    <div id="temp-login-error" style="color:red; margin-bottom:10px; display:none;">ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯</div>
                    <button id="temp-login-button" style="width:100%; padding:10px; background:#007bff; color:white; border:none; border-radius:4px; cursor:pointer;">ç™»å½•</button>
                </div>
            `;
            
            document.body.appendChild(tempLoginForm);
            
            // æ·»åŠ ä¸´æ—¶ç™»å½•è¡¨å•çš„äº‹ä»¶ç›‘å¬
            document.getElementById('temp-login-button').addEventListener('click', function() {
                const username = document.getElementById('temp-username').value;
                const password = document.getElementById('temp-password').value;
                
                if (username && password) {
                    // æ¨¡æ‹Ÿç™»å½•éªŒè¯
                    currentUser = { username: username, role: 'admin' };
                    isLoggedIn = true;
                    localStorage.setItem('bridgeSystemUser', JSON.stringify(currentUser));
                    
                    // ç§»é™¤ä¸´æ—¶ç™»å½•è¡¨å•
                    document.body.removeChild(tempLoginForm);
                    
                    // åˆ·æ–°é¡µé¢ä»¥åº”ç”¨æ­£ç¡®çš„ç™»å½•çŠ¶æ€
                    location.reload();
                } else {
                    document.getElementById('temp-login-error').style.display = 'block';
                }
            });
        }

        function hideLoginModal() {
            if (loginModal) {
                loginModal.style.display = 'none';
            }
        }

        function handleLogin() {
            console.log("å¤„ç†ç™»å½•è¯·æ±‚");
            const username = usernameInput ? usernameInput.value : '';
            const password = passwordInput ? passwordInput.value : '';
            
            if (username && password) {
                // ç®€åŒ–ç‰ˆæœ¬ï¼šä»»ä½•éç©ºç”¨æˆ·åå’Œå¯†ç éƒ½è¢«æ¥å—
                currentUser = {
                    username: username,
                    role: 'admin',
                    loginTime: new Date().toISOString()
                };
                isLoggedIn = true;
                
                // å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åœ¨localStorageä¸­
                localStorage.setItem('bridgeSystemUser', JSON.stringify(currentUser));
                
                // æ›´æ–°UI
                showUserInfo();
                hideLoginModal();
                
                console.log("ç™»å½•æˆåŠŸ:", username);
            } else {
                if (loginError) {
                    loginError.textContent = 'è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ';
                    loginError.style.display = 'block';
                }
                console.warn("ç™»å½•å¤±è´¥: ç”¨æˆ·åæˆ–å¯†ç ä¸ºç©º");
            }
        }

        function handleLogout() {
            console.log("å¤„ç†ç™»å‡ºè¯·æ±‚");
            // æ¸…é™¤ç”¨æˆ·ä¿¡æ¯
            localStorage.removeItem('bridgeSystemUser');
            currentUser = null;
            isLoggedIn = false;
            
            // æ›´æ–°UI
            hideUserInfo();
            showLoginModal();
        }

        // åˆå§‹åŒ–æ¡¥æ¢ç›‘æ§å›¾
        function initBridgeMonitor() {
            const bridge = document.querySelector('.bridge');
            const noMonitorMessage = document.getElementById('noMonitorMessage');
            
            if (!sensorData || sensorData.length === 0) {
                noMonitorMessage.style.display = 'block';
                return;
            }
            
            noMonitorMessage.style.display = 'none';
            
            // æ¸…é™¤ç°æœ‰ä¼ æ„Ÿå™¨ç‚¹
            document.querySelectorAll('.sensor-point').forEach(point => point.remove());
            
            // åˆ›å»ºä¼ æ„Ÿå™¨ç‚¹
            const uniqueSensors = [...new Set(sensorData.map(item => item.sensorId))];
            
            uniqueSensors.forEach((sensorId, index) => {
                // è·å–è¯¥ä¼ æ„Ÿå™¨çš„æ‰€æœ‰æ•°æ®ç‚¹
                const sensorPoints = sensorData.filter(item => item.sensorId === sensorId);
                
                // åˆ¤æ–­ä¼ æ„Ÿå™¨çŠ¶æ€
                let status = 'normal';
                for (const point of sensorPoints) {
                    if (point.status === 'danger') {
                        status = 'danger';
                        break;
                    } else if (point.status === 'warning') {
                        status = 'warning';
                    }
                }
                
                // è®¡ç®—ä½ç½®ï¼ˆå‡åŒ€åˆ†å¸ƒåœ¨æ¡¥é¢ä¸Šï¼‰
                const xPos = 10 + (80 * index / (uniqueSensors.length > 1 ? uniqueSensors.length - 1 : 1)) + '%';
                const yPos = '120px'; // æ”¾åœ¨æ¡¥é¢ä¸Š
                
                // åˆ›å»ºä¼ æ„Ÿå™¨ç‚¹å…ƒç´ 
                const sensorPoint = document.createElement('div');
                sensorPoint.className = `sensor-point ${status}`;
                sensorPoint.style.left = xPos;
                sensorPoint.style.top = yPos;
                sensorPoint.dataset.sensorId = sensorId;
                sensorPoint.dataset.status = status;
                
                // æ·»åŠ æ‚¬åœäº‹ä»¶æ˜¾ç¤ºå·¥å…·æç¤º
                sensorPoint.addEventListener('mouseover', function(e) {
                    const rect = this.getBoundingClientRect();
                    
                    // ç»Ÿè®¡å¼‚å¸¸æ•°é‡
                    const abnormalCount = sensorPoints.filter(p => p.status === 'danger').length;
                    
                    sensorTooltip.innerHTML = `
                        <strong>ä¼ æ„Ÿå™¨:</strong> ${sensorId}<br>
                        <strong>çŠ¶æ€:</strong> ${getStatusText(status)}<br>
                        <strong>å¼‚å¸¸ç‚¹æ•°:</strong> ${abnormalCount}
                    `;
                    
                    sensorTooltip.style.top = `${rect.top - 70}px`;
                    sensorTooltip.style.left = `${rect.left}px`;
                    sensorTooltip.style.opacity = '1';
                });
                
                sensorPoint.addEventListener('mouseout', function() {
                    sensorTooltip.style.opacity = '0';
                });
                
                // ç‚¹å‡»è·³è½¬åˆ°å¯¹åº”ä¼ æ„Ÿå™¨çš„åˆ†æç»“æœ
                sensorPoint.addEventListener('click', function() {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.tab[data-tab="analysis"]').classList.add('active');
                    
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById('analysis-tab').classList.add('active');
                    
                    // æ»šåŠ¨åˆ°å¼‚å¸¸åˆ—è¡¨ä½ç½®
                    document.querySelector('.result-area').scrollIntoView({ behavior: 'smooth' });
                    
                    // é«˜äº®æ˜¾ç¤ºå¯¹åº”ä¼ æ„Ÿå™¨çš„å¼‚å¸¸
                    document.querySelectorAll('.anomaly-item').forEach(item => {
                        if (item.textContent.includes(sensorId)) {
                            item.style.backgroundColor = '#fff3cd';
                            setTimeout(() => {
                                item.style.backgroundColor = '';
                            }, 2000);
                        }
                    });
                });
                
                bridge.appendChild(sensorPoint);
            });
        }

        function getStatusText(status) {
            switch(status) {
                case 'normal':
                    return 'æ­£å¸¸';
                case 'warning':
                    return 'è­¦å‘Š';
                case 'danger':
                    return 'å¼‚å¸¸';
                default:
                    return 'æœªçŸ¥';
            }
        }

        // åˆå§‹åŒ–æ‘„åƒå¤´ç›‘æ§ç³»ç»Ÿ
        function initCameraMonitor() {
            console.log("åˆå§‹åŒ–æ‘„åƒå¤´ç›‘æ§ç³»ç»Ÿ");
            
            // æ£€æŸ¥æ‘„åƒå¤´å®¹å™¨æ˜¯å¦å­˜åœ¨
            const cameraContainerElement = document.getElementById('camera-container');
            if (!cameraContainerElement) {
                console.warn("æ‘„åƒå¤´å®¹å™¨æœªæ‰¾åˆ°ï¼Œå¯èƒ½åœ¨é”™è¯¯çš„é¡µé¢ä¸Šå°è¯•åˆå§‹åŒ–æ‘„åƒå¤´");
                return; // æå‰è¿”å›é¿å…é”™è¯¯
            }
            
            // æ¸…ç©ºæ‘„åƒå¤´å®¹å™¨
            cameraContainerElement.innerHTML = '';
            
            // å®šä¹‰æ‘„åƒå¤´ä½ç½®å’Œå¯¹åº”çš„ä¼ æ„Ÿå™¨
            const cameraLocations = [
                { id: 1, name: "æ¡¥æ¢åŒ—ç«¯-å·¦ä¾§", status: "online", sensorId: "TL-101" },
                { id: 2, name: "æ¡¥æ¢åŒ—ç«¯-å³ä¾§", status: "online", sensorId: "TR-102" },
                { id: 3, name: "æ¡¥æ¢ä¸»è·¨-A1", status: "online", sensorId: "MA-201" },
                { id: 4, name: "æ¡¥æ¢ä¸»è·¨-A2", status: "online", sensorId: "MA-202" },
                { id: 5, name: "æ¡¥æ¢ä¸»è·¨-B1", status: "warning", sensorId: "MB-203" },
                { id: 6, name: "æ¡¥æ¢ä¸»è·¨-B2", status: "online", sensorId: "MB-204" },
                { id: 7, name: "æ¡¥æ¢ä¸»è·¨-C1", status: "offline", sensorId: "MC-205" },
                { id: 8, name: "æ¡¥æ¢ä¸»è·¨-C2", status: "online", sensorId: "MC-206" },
                { id: 9, name: "æ¡¥æ¢å—ç«¯-å·¦ä¾§", status: "online", sensorId: "BL-301" },
                { id: 10, name: "æ¡¥æ¢å—ç«¯-å³ä¾§", status: "warning", sensorId: "BR-302" },
                { id: 11, name: "æ¡¥å¢©-åŒ—1", status: "online", sensorId: "PN-401" },
                { id: 12, name: "æ¡¥å¢©-åŒ—2", status: "online", sensorId: "PN-402" },
                { id: 13, name: "æ¡¥å¢©-ä¸­1", status: "offline", sensorId: "PM-403" },
                { id: 14, name: "æ¡¥å¢©-ä¸­2", status: "online", sensorId: "PM-404" },
                { id: 15, name: "æ¡¥å¢©-å—1", status: "online", sensorId: "PS-405" },
                { id: 16, name: "æ¡¥å¢©-å—2", status: "online", sensorId: "PS-406" },
                { id: 17, name: "å¼•æ¡¥æ®µ-åŒ—", status: "warning", sensorId: "AN-501" },
                { id: 18, name: "å¼•æ¡¥æ®µ-å—", status: "online", sensorId: "AS-502" },
                { id: 19, name: "è¾…åŠ©é€šé“-ä¸œ", status: "offline", sensorId: "SE-601" },
                { id: 20, name: "è¾…åŠ©é€šé“-è¥¿", status: "online", sensorId: "SW-602" }
            ];
            
            // åˆ›å»ºæ‘„åƒå¤´å…ƒç´ 
            cameraLocations.forEach(camera => {
                const cameraItem = createCameraItem(camera);
                cameraContainerElement.appendChild(cameraItem);
            });
            
            // è®¾ç½®ç­›é€‰å™¨å’Œæœç´¢åŠŸèƒ½
            const cameraFilter = document.getElementById('camera-filter');
            const cameraSearch = document.getElementById('camera-search');
            
            cameraFilter.addEventListener('change', function() {
                filterCameras();
            });
            
            cameraSearch.addEventListener('input', function() {
                filterCameras();
            });
            
            // è®¾ç½®è§†å›¾åˆ‡æ¢åŠŸèƒ½
            const viewGrid = document.getElementById('view-grid');
            const viewList = document.getElementById('view-list');
            
            viewGrid.addEventListener('click', function() {
                cameraContainer.className = 'camera-grid';
                this.classList.add('secondary');
                viewList.classList.remove('secondary');
            });
            
            viewList.addEventListener('click', function() {
                cameraContainer.className = 'camera-list';
                this.classList.add('secondary');
                viewGrid.classList.remove('secondary');
            });
            
            // æ›´æ–°ç³»ç»ŸçŠ¶æ€
            updateSystemStatus(cameraLocations);
        }

        // åˆ›å»ºå•ä¸ªæ‘„åƒå¤´é¡¹
        function createCameraItem(camera) {
            const cameraItem = document.createElement('div');
            cameraItem.className = 'camera-item';
            cameraItem.dataset.cameraId = camera.id;
            cameraItem.dataset.status = camera.status;
            cameraItem.dataset.sensorId = camera.sensorId;
            
            // åˆ›å»ºæ‘„åƒå¤´å¤´éƒ¨
            const cameraHeader = document.createElement('div');
            cameraHeader.className = 'camera-header';
            
            const cameraName = document.createElement('span');
            cameraName.className = 'camera-name';
            cameraName.textContent = `æ‘„åƒå¤´ #${camera.id}`;
            
            const cameraStatus = document.createElement('span');
            cameraStatus.className = `camera-status ${camera.status}`;
            cameraStatus.textContent = getStatusText(camera.status);
            
            cameraHeader.appendChild(cameraName);
            cameraHeader.appendChild(cameraStatus);
            cameraItem.appendChild(cameraHeader);
            
            // æ·»åŠ ä½ç½®æ ‡ç­¾
            const locationTag = document.createElement('span');
            locationTag.className = 'location-tag';
            locationTag.textContent = camera.name;
            cameraItem.appendChild(locationTag);
            
            // æ·»åŠ ä¼ æ„Ÿå™¨ID
            const sensorId = document.createElement('div');
            sensorId.className = 'sensor-id';
            sensorId.innerHTML = `<strong>ä¼ æ„Ÿå™¨:</strong> ${camera.sensorId}`;
            cameraItem.appendChild(sensorId);
            
            // åˆ›å»ºæ‘„åƒå¤´è§†å›¾
            const cameraView = document.createElement('div');
            cameraView.className = 'camera-view';
            
            // åªæœ‰åœ¨çº¿çš„æ‘„åƒå¤´æ‰åŠ è½½éšæœºå›¾åƒ
            if (camera.status === 'online' || camera.status === 'warning') {
                // åˆ›å»ºå›¾åƒå ä½ç¬¦
                const placeholder = document.createElement('div');
                placeholder.className = 'camera-placeholder';
                
                const cameraIcon = document.createElement('span');
                cameraIcon.className = 'material-icons camera-icon';
                cameraIcon.textContent = 'videocam';
                
                const message = document.createElement('div');
                message.className = 'camera-message';
                message.textContent = 'ç‚¹å‡»æŸ¥çœ‹å®æ—¶ç›‘æ§';
                
                placeholder.appendChild(cameraIcon);
                placeholder.appendChild(message);
                cameraView.appendChild(placeholder);
            } else {
                // åˆ›å»ºç¦»çº¿å ä½ç¬¦
                const placeholder = document.createElement('div');
                placeholder.className = 'camera-placeholder';
                
                const cameraIcon = document.createElement('span');
                cameraIcon.className = 'material-icons camera-icon';
                cameraIcon.textContent = 'videocam_off';
                
                const message = document.createElement('div');
                message.className = 'camera-message';
                message.textContent = 'æ‘„åƒå¤´ç¦»çº¿';
                
                placeholder.appendChild(cameraIcon);
                placeholder.appendChild(message);
                cameraView.appendChild(placeholder);
            }
            
            // åˆ›å»ºæ‘„åƒå¤´è¦†ç›–å±‚
            const cameraOverlay = document.createElement('div');
            cameraOverlay.className = 'camera-overlay';
            
            // æ·»åŠ æ“ä½œæŒ‰é’®
            const viewButton = document.createElement('button');
            viewButton.className = 'camera-control-btn';
            viewButton.innerHTML = '<span class="material-icons">fullscreen</span>';
            viewButton.dataset.action = 'view';
            viewButton.dataset.camera = camera.id;
            viewButton.addEventListener('click', function(e) {
                e.stopPropagation();
                viewCamera(camera.id);
            });
            
            cameraOverlay.appendChild(viewButton);
            cameraView.appendChild(cameraOverlay);
            
            // è®¾ç½®æ‘„åƒå¤´ç‚¹å‡»äº‹ä»¶
            cameraView.addEventListener('click', function() {
                if (camera.status !== 'offline') {
                    viewCamera(camera.id);
                } else {
                    alert(`æ‘„åƒå¤´ #${camera.id} (${camera.name}) å½“å‰ç¦»çº¿ï¼Œæ— æ³•æŸ¥çœ‹ç”»é¢`);
                }
            });
            
            cameraItem.appendChild(cameraView);
            
            // æ·»åŠ æ‘„åƒå¤´æ§åˆ¶æŒ‰é’®
            const cameraControls = document.createElement('div');
            cameraControls.className = 'camera-controls';
            
            // åªæœ‰åœ¨çº¿çš„æ‘„åƒå¤´æ‰èƒ½æ§åˆ¶
            if (camera.status !== 'offline') {
                const controlButtons = [
                    { action: 'history', icon: 'history', text: 'å†å²è®°å½•' },
                    { action: 'refresh', icon: 'refresh', text: 'åˆ·æ–°' }
                ];
                
                controlButtons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'camera-control-btn';
                    button.title = btn.text;
                    button.innerHTML = `<span class="material-icons">${btn.icon}</span>`;
                    button.dataset.action = btn.action;
                    button.dataset.camera = camera.id;
                    button.addEventListener('click', function() {
                        controlCamera(camera.id, btn.action);
                    });
                    cameraControls.appendChild(button);
                });
            } else {
                const reconnectButton = document.createElement('button');
                reconnectButton.className = 'camera-control-btn';
                reconnectButton.title = 'å°è¯•é‡è¿';
                reconnectButton.innerHTML = '<span class="material-icons">sync</span>';
                reconnectButton.dataset.action = 'reconnect';
                reconnectButton.dataset.camera = camera.id;
                reconnectButton.addEventListener('click', function() {
                    attemptReconnect(camera.id);
                });
                cameraControls.appendChild(reconnectButton);
            }
            
            cameraItem.appendChild(cameraControls);
            
            return cameraItem;
        }

        // ç­›é€‰æ‘„åƒå¤´
        function filterCameras() {
            const filterValue = document.getElementById('camera-filter').value;
            const searchText = document.getElementById('camera-search').value.toLowerCase();
            
            const cameraItems = document.querySelectorAll('.camera-item');
            
            cameraItems.forEach(item => {
                const cameraStatus = item.dataset.status;
                const cameraId = item.dataset.cameraId;
                const cameraName = item.querySelector('.camera-name').textContent.toLowerCase();
                const locationName = item.querySelector('.location-tag').textContent.toLowerCase();
                const sensorId = item.dataset.sensorId.toLowerCase();
                
                let statusMatch = true;
                if (filterValue !== 'all') {
                    statusMatch = cameraStatus === filterValue;
                }
                
                const searchMatch = 
                    cameraName.includes(searchText) || 
                    locationName.includes(searchText) || 
                    sensorId.includes(searchText) ||
                    `æ‘„åƒå¤´ ${cameraId}`.toLowerCase().includes(searchText);
                
                if (statusMatch && searchMatch) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
            
            // æ›´æ–°æ— ç»“æœæ¶ˆæ¯
            let visibleCount = 0;
            cameraItems.forEach(item => {
                if (item.style.display !== 'none') {
                    visibleCount++;
                }
            });
            
            if (visibleCount === 0) {
                // å¦‚æœæ²¡æœ‰åŒ¹é…é¡¹ï¼Œæ˜¾ç¤ºæ¶ˆæ¯
                let noResultMessage = document.getElementById('no-camera-results');
                if (!noResultMessage) {
                    noResultMessage = document.createElement('div');
                    noResultMessage.id = 'no-camera-results';
                    noResultMessage.className = 'no-data-message';
                    noResultMessage.textContent = 'æ²¡æœ‰åŒ¹é…çš„æ‘„åƒå¤´';
                    cameraContainer.appendChild(noResultMessage);
                } else {
                    noResultMessage.style.display = 'block';
                }
            } else {
                // éšè—æ¶ˆæ¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                const noResultMessage = document.getElementById('no-camera-results');
                if (noResultMessage) {
                    noResultMessage.style.display = 'none';
                }
            }
        }

        // æŸ¥çœ‹æ‘„åƒå¤´ç”»é¢
        function viewCamera(cameraId) {
            console.log(`æŸ¥çœ‹æ‘„åƒå¤´ #${cameraId} ç”»é¢`);
            
            // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šå¼¹å‡ºä¸€ä¸ªæ¨¡æ€æ¡†æ˜¾ç¤ºå®æ—¶è§†é¢‘
            alert(`æ­£åœ¨æ‰“å¼€æ‘„åƒå¤´ #${cameraId} çš„å®æ—¶ç›‘æ§ç”»é¢`);
            
            // æ¨¡æ‹ŸåŠ è½½æ–°ç”»é¢
            const camera = document.querySelector(`.camera-item[data-camera-id="${cameraId}"] .camera-placeholder`);
            if (camera) {
                camera.querySelector('.camera-message').textContent = 'æ­£åœ¨åŠ è½½å®æ—¶ç”»é¢...';
                camera.querySelector('.camera-icon').textContent = 'sync';
                
                // 2ç§’åæ¢å¤
                setTimeout(() => {
                    camera.querySelector('.camera-message').textContent = 'ç‚¹å‡»æŸ¥çœ‹å®æ—¶ç›‘æ§';
                    camera.querySelector('.camera-icon').textContent = 'videocam';
                }, 2000);
            }
        }

        // å°è¯•é‡è¿æ‘„åƒå¤´
        function attemptReconnect(cameraId) {
            console.log(`å°è¯•é‡è¿æ‘„åƒå¤´ #${cameraId}`);
            
            const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
            if (!cameraItem) return;
            
            // ä¿®æ”¹æ‘„åƒå¤´å ä½ç¬¦æ˜¾ç¤ºé‡è¿çŠ¶æ€
            const placeholder = cameraItem.querySelector('.camera-placeholder');
            placeholder.querySelector('.camera-message').textContent = 'æ­£åœ¨å°è¯•é‡æ–°è¿æ¥...';
            placeholder.querySelector('.camera-icon').textContent = 'sync';
            
            // æ¨¡æ‹Ÿé‡è¿è¿‡ç¨‹
            let connectionAttempts = 0;
            const maxAttempts = 3;
            
            const attemptInterval = setInterval(() => {
                connectionAttempts++;
                console.log(`é‡è¿å°è¯• ${connectionAttempts}/${maxAttempts}`);
                
                if (connectionAttempts >= maxAttempts && Math.random() > 0.7) {
                    // æ¨¡æ‹Ÿé‡è¿æˆåŠŸ
                    clearInterval(attemptInterval);
                    
                    // æ›´æ–°çŠ¶æ€ä¸ºåœ¨çº¿
                    const statusBadge = cameraItem.querySelector('.camera-status');
                    statusBadge.textContent = 'åœ¨çº¿';
                    statusBadge.className = 'camera-status online';
                    cameraItem.dataset.status = 'online';
                    
                    // æ›´æ–°å›¾æ ‡å’Œæ¶ˆæ¯
                    placeholder.querySelector('.camera-message').textContent = 'æ‘„åƒå¤´å·²æ¢å¤è¿æ¥';
                    placeholder.querySelector('.camera-icon').textContent = 'videocam';
                    
                    // æ›¿æ¢æ§åˆ¶æŒ‰é’®
                    const cameraControls = cameraItem.querySelector('.camera-controls');
                    cameraControls.innerHTML = '';
                    
                    const controlButtons = [
                        { action: 'history', icon: 'history', text: 'å†å²è®°å½•' },
                        { action: 'refresh', icon: 'refresh', text: 'åˆ·æ–°' }
                    ];
                    
                    controlButtons.forEach(btn => {
                        const button = document.createElement('button');
                        button.className = 'camera-control-btn';
                        button.title = btn.text;
                        button.innerHTML = `<span class="material-icons">${btn.icon}</span>`;
                        button.dataset.action = btn.action;
                        button.dataset.camera = cameraId;
                        button.addEventListener('click', function() {
                            controlCamera(cameraId, btn.action);
                        });
                        cameraControls.appendChild(button);
                    });
                    
                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    showActionFeedback(cameraId, 'æ‘„åƒå¤´å·²æ¢å¤è¿æ¥');
                    
                    // æ›´æ–°ç³»ç»ŸçŠ¶æ€
                    updateSystemStatus();
                } else if (connectionAttempts >= maxAttempts) {
                    // æ¨¡æ‹Ÿé‡è¿å¤±è´¥
                    clearInterval(attemptInterval);
                    
                    // æ¢å¤ç¦»çº¿çŠ¶æ€
                    placeholder.querySelector('.camera-message').textContent = 'é‡è¿å¤±è´¥ï¼Œæ‘„åƒå¤´ç¦»çº¿';
                    placeholder.querySelector('.camera-icon').textContent = 'videocam_off';
                    
                    // æ˜¾ç¤ºå¤±è´¥æ¶ˆæ¯
                    showActionFeedback(cameraId, 'é‡è¿å¤±è´¥');
                }
            }, 1000);
        }

        // æ›´æ–°ç³»ç»ŸçŠ¶æ€ä¿¡æ¯
        function updateSystemStatus() {
            // ç»Ÿè®¡æ‘„åƒå¤´çŠ¶æ€
            const cameras = document.querySelectorAll('.camera-item');
            let onlineCount = 0;
            let offlineCount = 0;
            let warningCount = 0;
            
            cameras.forEach(camera => {
                const status = camera.dataset.status;
                if (status === 'online') onlineCount++;
                else if (status === 'offline') offlineCount++;
                else if (status === 'warning') warningCount++;
            });
            
            const systemStatus = document.getElementById('system-status');
            
            if (offlineCount > 0 || warningCount > 0) {
                let statusMessage = `æ‘„åƒå¤´çŠ¶æ€: ${onlineCount} åœ¨çº¿`;
                if (warningCount > 0) statusMessage += `, ${warningCount} è­¦å‘Š`;
                if (offlineCount > 0) statusMessage += `, ${offlineCount} ç¦»çº¿`;
                
                systemStatus.textContent = statusMessage;
                
                if (offlineCount > 0) {
                    document.getElementById('cameraAlert').style.color = '#dc3545';
                } else {
                    document.getElementById('cameraAlert').style.color = '#ffc107';
                }
            } else {
                systemStatus.textContent = 'ç›‘æ§ç³»ç»Ÿè¿è¡Œæ­£å¸¸ï¼Œæ‰€æœ‰æ‘„åƒå¤´åœ¨çº¿';
                document.getElementById('cameraAlert').style.color = '#28a745';
            }
        }

        // æ¨¡æ‹Ÿæ‘„åƒå¤´æ§åˆ¶
        function controlCamera(cameraId, action) {
            console.log(`æ§åˆ¶æ‘„åƒå¤´ #${cameraId}ï¼ŒåŠ¨ä½œ: ${action}`);
            
            const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
            if (!cameraItem) return;
            
            // æ˜¾ç¤ºæ§åˆ¶åé¦ˆï¼ˆé—ªçƒæ•ˆæœï¼‰
            const placeholder = cameraItem.querySelector('.camera-placeholder');
            placeholder.style.opacity = '0.7';
            setTimeout(() => {
                placeholder.style.opacity = '1';
            }, 200);
            
            // æ ¹æ®åŠ¨ä½œæ‰§è¡Œä¸åŒçš„æ¨¡æ‹Ÿæ“ä½œ
            switch(action) {
                case 'history':
                    // æ¨¡æ‹ŸæŸ¥çœ‹å†å²è®°å½•
                    showActionFeedback(cameraId, 'æ­£åœ¨åŠ è½½å†å²è®°å½•');
                    break;
                case 'refresh':
                    // åˆ·æ–°æ‘„åƒå¤´
                    showActionFeedback(cameraId, 'æ­£åœ¨åˆ·æ–°è¿æ¥');
                    break;
            }
        }

        // æ˜¾ç¤ºæ‘„åƒå¤´æ“ä½œåé¦ˆ
        function showActionFeedback(cameraId, message) {
            const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
            if (!cameraItem) return;
            
            // åˆ›å»ºåé¦ˆå…ƒç´ 
            const feedback = document.createElement('div');
            feedback.className = 'camera-feedback';
            feedback.style.position = 'absolute';
            feedback.style.bottom = '10px';
            feedback.style.left = '50%';
            feedback.style.transform = 'translateX(-50%)';
            feedback.style.backgroundColor = 'rgba(0,0,0,0.7)';
            feedback.style.color = 'white';
            feedback.style.padding = '5px 10px';
            feedback.style.borderRadius = '4px';
            feedback.style.fontSize = '12px';
            feedback.style.zIndex = '100';
            feedback.textContent = message;
            
            // æ·»åŠ åˆ°æ‘„åƒå¤´è§†å›¾
            const cameraView = cameraItem.querySelector('.camera-view');
            cameraView.appendChild(feedback);
            
            // 2ç§’åç§»é™¤åé¦ˆ
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.remove();
                }
            }, 2000);
        }

        // æ ‡ç­¾é¡µåˆ‡æ¢åŠŸèƒ½
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                
                // æ›´æ–°æ ‡ç­¾é¡µçŠ¶æ€
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // æ›´æ–°å†…å®¹åŒºåŸŸ
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                // å¦‚æœåˆ‡æ¢åˆ°ç›‘æ§æ ‡ç­¾ï¼Œåˆå§‹åŒ–ç›¸åº”åŠŸèƒ½
                if (tabId === 'monitor') {
                    // åˆå§‹åŒ–æ‘„åƒå¤´ç›‘æ§è€Œä¸æ˜¯æ¡¥æ¢ç›‘æ§
                    initCameraMonitor();
                }
            });
        });

        // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                const file = this.files[0];
                fileInfo.textContent = `å·²é€‰æ‹©æ–‡ä»¶: ${file.name} (${formatFileSize(file.size)})`;
                uploadButton.disabled = false;
            } else {
                fileInfo.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                uploadButton.disabled = true;
            }
        });

        // ä¸Šä¼ æŒ‰é’®äº‹ä»¶
        uploadButton.addEventListener('click', function() {
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        // æ·»åŠ è°ƒè¯•ä¿¡æ¯
                        console.log("æ–‡ä»¶å†…å®¹è¯»å–æˆåŠŸï¼Œé•¿åº¦ï¼š", content.length);
                        processData(content);
                        
                        // ç¡®ä¿æ•°æ®å¤„ç†åå¯ç”¨æ£€æµ‹æŒ‰é’®
                        if (sensorData.length > 0) {
                            console.log("æˆåŠŸåŠ è½½æ•°æ®ç‚¹ï¼š", sensorData.length);
                            detectButton.disabled = false;
                        } else {
                            console.warn("æ•°æ®å¤„ç†å®Œæˆï¼Œä½†æ²¡æœ‰æœ‰æ•ˆæ•°æ®ç‚¹");
                            alert('æœªèƒ½ä»æ–‡ä»¶ä¸­æå–æœ‰æ•ˆæ•°æ®ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
                            detectButton.disabled = true;
                        }
                    } catch (error) {
                        console.error('æ•°æ®è§£æé”™è¯¯:', error);
                        alert('æ•°æ®è§£æé”™è¯¯: ' + error.message);
                    }
                };
                reader.onerror = function(e) {
                    console.error('æ–‡ä»¶è¯»å–é”™è¯¯:', e);
                    alert('æ–‡ä»¶è¯»å–é”™è¯¯!');
                };
                reader.readAsText(file);
            } else {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶!');
            }
        });

        // é‡ç½®æŒ‰é’®äº‹ä»¶
        resetButton.addEventListener('click', function() {
            resetAll();
        });

        // å¼€å§‹æ£€æµ‹æŒ‰é’®äº‹ä»¶
        detectButton.addEventListener('click', function() {
            console.log("ç‚¹å‡»æ£€æµ‹æŒ‰é’®ï¼Œå½“å‰æ•°æ®ç‚¹æ•°é‡:", sensorData.length);
            if (sensorData && sensorData.length > 0) {
                console.log("å¼€å§‹å¼‚å¸¸æ£€æµ‹...");
                startAnomalyDetection();
            } else {
                console.warn("æ²¡æœ‰æ•°æ®å¯ä¾›æ£€æµ‹");
                alert('è¯·å…ˆä¸Šä¼ æ•°æ®!');
            }
        });

        // ç™»å½•æŒ‰é’®äº‹ä»¶
        loginButton.addEventListener('click', handleLogin);

        // é€€å‡ºæŒ‰é’®äº‹ä»¶
        logoutButton.addEventListener('click', handleLogout);

        // æ”¯æŒå›è½¦ç™»å½•
        passwordInput.addEventListener('keyup', function(event) {
            if (event.key === 'Enter') {
                handleLogin();
            }
        });

        // æ¨¡æ‹Ÿå¼‚å¸¸æ£€æµ‹è¿‡ç¨‹
        function startAnomalyDetection() {
            noAnalysisMessage.style.display = 'none';
            analysisLoader.style.display = 'block';
            analysisSummary.style.display = 'none';
            anomalyList.innerHTML = '';
            
            // æ¨¡æ‹Ÿå¼‚å¸¸æ£€æµ‹å»¶è¿Ÿ
            setTimeout(() => {
                // æ‰§è¡Œå¼‚å¸¸æ£€æµ‹
                const result = detectAnomalies();
                
                analysisLoader.style.display = 'none';
                analysisSummary.style.display = 'block';
                
                // åˆ›å»ºå›¾è¡¨
                createAnomalyChart();
                
                // æ›´æ–°ç›‘æ§è§†å›¾
                initBridgeMonitor();
                
                // æ·»åŠ åˆ°å†å²è®°å½•
                addToDetectionHistory(result);
                
                // è‡ªåŠ¨åˆ‡æ¢åˆ°åˆ†ææ ‡ç­¾
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector('.tab[data-tab="analysis"]').classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById('analysis-tab').classList.add('active');
            }, 2000);
        }

        // å¤„ç†ä¸Šä¼ çš„æ•°æ®
        function processData(content) {
            try {
                const lines = content.split('\n');
                console.log("æ–‡ä»¶è¡Œæ•°:", lines.length);
                
                sensorData = [];
                
                let validLines = 0;
                let skippedLines = 0;
                
                lines.forEach((line, index) => {
                    if (line.trim() !== '') {
                        const parts = line.split(',');
                        // ä¿®æ”¹é€»è¾‘ï¼Œæ”¯æŒæ›´çµæ´»çš„æ•°æ®æ ¼å¼
                        if (parts.length >= 2) {
                            try {
                                const timestamp = parts[0].trim();
                                const sensorId = parts.length >= 3 ? parts[1].trim() : `ä¼ æ„Ÿå™¨${index+1}`;
                                const valueIndex = parts.length >= 3 ? 2 : 1;
                                const valueStr = parts[valueIndex].trim();
                                const value = parseFloat(valueStr);
                                
                                if (!isNaN(value)) {
                                    sensorData.push({
                                        timestamp: timestamp,
                                        sensorId: sensorId,
                                        value: value,
                                        status: 'normal'
                                    });
                                    validLines++;
                                } else {
                                    console.warn(`ç¬¬${index+1}è¡Œæ•°å€¼æ— æ•ˆ: "${valueStr}"`);
                                    skippedLines++;
                                }
                            } catch (e) {
                                console.warn(`è§£æç¬¬${index+1}è¡Œæ—¶å‡ºé”™:`, e.message, "è¡Œå†…å®¹:", line);
                                skippedLines++;
                            }
                        } else {
                            console.warn(`ç¬¬${index+1}è¡Œæ ¼å¼ä¸æ­£ç¡®ï¼Œè‡³å°‘éœ€è¦2ä¸ªå€¼: ${line}`);
                            skippedLines++;
                        }
                    }
                });
                
                console.log(`æ•°æ®å¤„ç†å®Œæˆ: æœ‰æ•ˆè¡Œæ•°=${validLines}, è·³è¿‡è¡Œæ•°=${skippedLines}`);
                
                // ç¡®ä¿å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿä¸ä¼šæŠ¥é”™
                if (sensorData.length === 0) {
                    console.warn("æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆæ•°æ®");
                }
                
                displayData();
                createChart();
                
            } catch (error) {
                console.error("å¤„ç†æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯:", error);
                alert("å¤„ç†æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: " + error.message);
            }
        }

        // ä¼˜åŒ–æ•°æ®æ˜¾ç¤ºå‡½æ•°
        function displayData() {
            if (!sensorData || sensorData.length === 0) {
                noDataMessage.style.display = 'block';
                noChartDataMessage.style.display = 'block';
                return;
            }
            
            // éšè—æ— æ•°æ®æç¤º
            noDataMessage.style.display = 'none';
            
            // æ¸…ç©ºè¡¨æ ¼
            const tableBody = dataTable.getElementsByTagName('tbody')[0];
            tableBody.innerHTML = '';
            
            // ä½¿ç”¨æ–‡æ¡£ç‰‡æ®µå‡å°‘DOMæ“ä½œ
            const fragment = document.createDocumentFragment();
            
            // æ˜¾ç¤ºæœ€æ–°çš„æ•°æ®ç‚¹ï¼ˆä¸ºäº†æ€§èƒ½ï¼Œæœ€å¤šæ˜¾ç¤º100æ¡ï¼‰
            const dataToShow = sensorData.slice(-100);
            
            // æ‰¹é‡åˆ›å»ºDOMå…ƒç´ 
            dataToShow.forEach(item => {
                const row = document.createElement('tr');
                
                const timestampCell = document.createElement('td');
                timestampCell.textContent = item.timestamp;
                
                const sensorIdCell = document.createElement('td');
                sensorIdCell.textContent = item.sensorId;
                
                const valueCell = document.createElement('td');
                valueCell.textContent = item.value.toFixed(2);
                
                const statusCell = document.createElement('td');
                const statusBadge = document.createElement('span');
                statusBadge.className = `status-badge status-${item.status}`;
                statusBadge.textContent = item.status === 'normal' ? 'æ­£å¸¸' : 
                                         item.status === 'warning' ? 'è­¦å‘Š' : 'å¼‚å¸¸';
                statusCell.appendChild(statusBadge);
                
                row.appendChild(timestampCell);
                row.appendChild(sensorIdCell);
                row.appendChild(valueCell);
                row.appendChild(statusCell);
                
                fragment.appendChild(row);
            });
            
            // ä¸€æ¬¡æ€§æ·»åŠ æ‰€æœ‰è¡Œï¼Œå‡å°‘é¡µé¢é‡æ’
            tableBody.appendChild(fragment);
        }

        // åˆ›å»ºå›¾è¡¨
        function createChart() {
            if (sensorData.length > 0) {
                noChartDataMessage.style.display = 'none';
                
                const ctx = document.getElementById('dataChart').getContext('2d');
                
                // é”€æ¯ç°æœ‰å›¾è¡¨
                if (dataChart) {
                    dataChart.destroy();
                }
                
                // æŒ‰ä¼ æ„Ÿå™¨ç±»å‹åˆ†ç»„
                const sensorTypes = ['æ¸©åº¦', 'åº”å˜', 'æŒ¯åŠ¨', 'å€¾è§’', 'å…¶ä»–'];
                let datasetsByType = {};
                
                // åˆå§‹åŒ–æ¯ç§ç±»å‹çš„æ•°æ®é›†
                sensorTypes.forEach(type => {
                    datasetsByType[type] = [];
                });
                
                // è·å–å”¯ä¸€çš„ä¼ æ„Ÿå™¨ID
                const uniqueSensors = [...new Set(sensorData.map(item => item.sensorId))];
                
                // ä¸ºæ¯ä¸ªä¼ æ„Ÿå™¨IDåˆ†é…ä¸€ç§é¢œè‰²
                const sensorColors = {};
                const baseColors = [
                    { r: 255, g: 99, b: 132 },   // çº¢è‰²ç³»
                    { r: 54, g: 162, b: 235 },   // è“è‰²ç³»
                    { r: 255, g: 206, b: 86 },   // é»„è‰²ç³»
                    { r: 75, g: 192, b: 192 },   // é’è‰²ç³»
                    { r: 153, g: 102, b: 255 },  // ç´«è‰²ç³»
                    { r: 255, g: 159, b: 64 },   // æ©™è‰²ç³»
                    { r: 99, g: 255, b: 132 },   // ç»¿è‰²ç³»
                    { r: 235, g: 54, b: 162 }    // ç²‰è‰²ç³»
                ];
                
                uniqueSensors.forEach((sensorId, index) => {
                    // å¾ªç¯ä½¿ç”¨é¢œè‰²
                    const colorIndex = index % baseColors.length;
                    const baseColor = baseColors[colorIndex];
                    
                    // ç¨å¾®è°ƒæ•´é¢œè‰²ï¼Œç¡®ä¿åŒä¸€ä¼ æ„Ÿå™¨ç±»å‹çš„é¢œè‰²ç›¸è¿‘ä½†å¯åŒºåˆ†
                    const variant = Math.floor(index / baseColors.length);
                    const r = Math.max(0, Math.min(255, baseColor.r - variant * 20));
                    const g = Math.max(0, Math.min(255, baseColor.g - variant * 20));
                    const b = Math.max(0, Math.min(255, baseColor.b - variant * 20));
                    
                    sensorColors[sensorId] = {
                        border: `rgba(${r}, ${g}, ${b}, 1)`,
                        background: `rgba(${r}, ${g}, ${b}, 0.1)`
                    };
                });
                
                // æŒ‰ä¼ æ„Ÿå™¨IDåˆ†ç»„æ•°æ®
                const datasets = [];
                
                uniqueSensors.forEach(sensorId => {
                    // ç¡®å®šä¼ æ„Ÿå™¨ç±»å‹
                    let sensorType = 'å…¶ä»–';
                    if (sensorId.includes('æ¸©åº¦')) sensorType = 'æ¸©åº¦';
                    else if (sensorId.includes('åº”å˜')) sensorType = 'åº”å˜';
                    else if (sensorId.includes('æŒ¯åŠ¨')) sensorType = 'æŒ¯åŠ¨';
                    else if (sensorId.includes('å€¾è§’')) sensorType = 'å€¾è§’';
                    
                    // è·å–è¯¥ä¼ æ„Ÿå™¨çš„æ‰€æœ‰æ•°æ®ç‚¹
                    const sensorPoints = sensorData.filter(item => item.sensorId === sensorId);
                    
                    // ä¸ºæ¯ä¸ªä¼ æ„Ÿå™¨åˆ›å»ºæ•°æ®é›†
                    const dataset = {
                        label: `${sensorType}: ${sensorId}`,
                        data: sensorPoints.map(item => ({
                            x: item.timestamp,
                            y: item.value
                        })),
                        borderColor: sensorColors[sensorId].border,
                        backgroundColor: sensorColors[sensorId].background,
                        borderWidth: 2,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        tension: 0.3,
                        fill: false,
                        hidden: false // é»˜è®¤æ˜¾ç¤ºæ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®
                    };
                    
                    // å°†æ•°æ®é›†æ·»åŠ åˆ°å¯¹åº”çš„ä¼ æ„Ÿå™¨ç±»å‹ç»„
                    datasetsByType[sensorType].push(dataset);
                });
                
                // åˆå¹¶æ‰€æœ‰æ•°æ®é›†
                sensorTypes.forEach(type => {
                    if (datasetsByType[type].length > 0) {
                        datasets.push(...datasetsByType[type]);
                    }
                });
                
                // åˆ›å»ºæ–°å›¾è¡¨ï¼Œä½¿ç”¨æ•£ç‚¹å›¾ä»¥æ”¯æŒä¸åŒæ—¶é—´è½´çš„æ•°æ®
                dataChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    boxWidth: 12,
                                    usePointStyle: true,
                                    generateLabels: function(chart) {
                                        // ç”Ÿæˆå›¾ä¾‹æ ‡ç­¾
                                        const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                        
                                        // æŒ‰ä¼ æ„Ÿå™¨ç±»å‹åˆ†ç»„å›¾ä¾‹
                                        const groupedLabels = {};
                                        sensorTypes.forEach(type => {
                                            groupedLabels[type] = [];
                                        });
                                        
                                        labels.forEach(label => {
                                            // ä»æ ‡ç­¾æ–‡æœ¬ä¸­æå–ä¼ æ„Ÿå™¨ç±»å‹
                                            const typeMatch = label.text.match(/^([^:]+):/);
                                            if (typeMatch) {
                                                const type = typeMatch[1].trim();
                                                if (sensorTypes.includes(type)) {
                                                    groupedLabels[type].push(label);
                                                } else {
                                                    groupedLabels['å…¶ä»–'].push(label);
                                                }
                                            } else {
                                                groupedLabels['å…¶ä»–'].push(label);
                                            }
                                        });
                                        
                                        // æ‰å¹³åŒ–åˆ†ç»„åçš„æ ‡ç­¾
                                        const result = [];
                                        sensorTypes.forEach(type => {
                                            if (groupedLabels[type].length > 0) {
                                                // æ·»åŠ ç±»å‹æ ‡é¢˜ï¼ˆä¸å¯ç‚¹å‡»ï¼‰
                                                result.push({
                                                    text: `${type}ä¼ æ„Ÿå™¨`,
                                                    fillStyle: 'rgba(0,0,0,0.1)',
                                                    strokeStyle: 'rgba(0,0,0,0.1)',
                                                    lineWidth: 0,
                                                    hidden: false,
                                                    index: -1, // ç¡®ä¿ä¸ä¸å®é™…æ•°æ®é›†å†²çª
                                                    isGroup: true
                                                });
                                                result.push(...groupedLabels[type]);
                                            }
                                        });
                                        
                                        return result;
                                    },
                                    onClick: function(e, legendItem, legend) {
                                        if (legendItem.isGroup) return; // å¦‚æœç‚¹å‡»çš„æ˜¯åˆ†ç»„æ ‡é¢˜ï¼Œä¸åšä»»ä½•æ“ä½œ
                                        
                                        // é»˜è®¤å›¾ä¾‹ç‚¹å‡»è¡Œä¸º
                                        const index = legendItem.datasetIndex;
                                        const ci = legend.chart;
                                        if (ci.isDatasetVisible(index)) {
                                            ci.hide(index);
                                            legendItem.hidden = true;
                                        } else {
                                            ci.show(index);
                                            legendItem.hidden = false;
                                        }
                                    }
                                }
                            },
                            tooltip: {
                                mode: 'nearest',
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        const dataset = context.dataset;
                                        const value = context.raw.y;
                                        return `${dataset.label}: ${value.toFixed(2)}`;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        scales: {
                            x: {
                                type: 'category',
                                grid: {
                                    display: false
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'ä¼ æ„Ÿå™¨å€¼'
                                }
                            }
                        }
                    }
                });
                
                // æ·»åŠ æ§åˆ¶é¢æ¿ï¼Œç”¨äºæŒ‰ä¼ æ„Ÿå™¨ç±»å‹ç­›é€‰æ˜¾ç¤º
                createChartControls(sensorTypes);
            } else {
                noChartDataMessage.style.display = 'block';
            }
        }

        // åˆ›å»ºå›¾è¡¨æ§åˆ¶é¢æ¿
        function createChartControls(sensorTypes) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ§åˆ¶é¢æ¿
            let controlPanel = document.getElementById('chart-controls');
            if (!controlPanel) {
                controlPanel = document.createElement('div');
                controlPanel.id = 'chart-controls';
                controlPanel.className = 'chart-controls';
                controlPanel.style.marginBottom = '15px';
                controlPanel.style.display = 'flex';
                controlPanel.style.flexWrap = 'wrap';
                controlPanel.style.gap = '10px';
                
                const chartContainer = document.getElementById('chart-container');
                chartContainer.insertBefore(controlPanel, document.getElementById('dataChart').parentNode);
            } else {
                controlPanel.innerHTML = ''; // æ¸…ç©ºç°æœ‰æ§ä»¶
            }
            
            // æ·»åŠ "å…¨éƒ¨æ˜¾ç¤º"æŒ‰é’®
            const showAllBtn = document.createElement('button');
            showAllBtn.textContent = 'æ˜¾ç¤ºå…¨éƒ¨';
            showAllBtn.className = 'chart-control-btn active';
            showAllBtn.style.padding = '5px 10px';
            showAllBtn.style.backgroundColor = '#4299e1';
            showAllBtn.style.color = 'white';
            showAllBtn.style.border = '1px solid #3182ce';
            showAllBtn.style.borderRadius = '4px';
            showAllBtn.style.cursor = 'pointer';
            
            showAllBtn.addEventListener('click', function() {
                if (dataChart) {
                    dataChart.data.datasets.forEach((dataset, index) => {
                        dataChart.setDatasetVisibility(index, true);
                    });
                    dataChart.update();
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    document.querySelectorAll('.chart-control-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                }
            });
            
            controlPanel.appendChild(showAllBtn);
            
            // ä¸ºæ¯ç§ä¼ æ„Ÿå™¨ç±»å‹æ·»åŠ ç­›é€‰æŒ‰é’®
            sensorTypes.forEach(type => {
                const button = document.createElement('button');
                button.textContent = `${type}ä¼ æ„Ÿå™¨`;
                button.className = 'chart-control-btn';
                button.style.padding = '5px 10px';
                button.style.backgroundColor = '#e2e8f0';
                button.style.border = '1px solid #cbd5e0';
                button.style.borderRadius = '4px';
                button.style.cursor = 'pointer';
                
                button.addEventListener('click', function() {
                    if (dataChart) {
                        // éšè—æ‰€æœ‰æ•°æ®é›†
                        dataChart.data.datasets.forEach((dataset, index) => {
                            const isCurrentType = dataset.label.startsWith(`${type}:`);
                            dataChart.setDatasetVisibility(index, isCurrentType);
                        });
                        dataChart.update();
                        
                        // æ›´æ–°æŒ‰é’®çŠ¶æ€
                        document.querySelectorAll('.chart-control-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        this.classList.add('active');
                    }
                });
                
                controlPanel.appendChild(button);
            });
            
            // æ·»åŠ CSSæ ·å¼
            const style = document.createElement('style');
            style.textContent = `
                .chart-control-btn {
                    transition: all 0.2s ease;
                }
                .chart-control-btn:hover {
                    opacity: 0.9;
                }
                .chart-control-btn.active {
                    background-color: #4299e1 !important;
                    color: white !important;
                    border-color: #3182ce !important;
                }
            `;
            document.head.appendChild(style);
        }

        // åˆ›å»ºå¼‚å¸¸æ£€æµ‹å›¾è¡¨
        function createAnomalyChart() {
            const ctx = document.getElementById('anomalyChart').getContext('2d');
            
            // é”€æ¯ç°æœ‰å›¾è¡¨
            if (anomalyChart) {
                anomalyChart.destroy();
            }
            
            // å‡†å¤‡å›¾è¡¨æ•°æ®
            const labels = Array.from({ length: zScores.length }, (_, i) => i + 1);
            
            // åˆ›å»ºZ-scoreæ•°æ®é›†
            const datasets = [
                {
                    label: 'Z-Score',
                    data: zScores,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderWidth: 2,
                    pointRadius: 3
                }
            ];
            
            // æ·»åŠ å¼‚å¸¸ç‚¹æ•°æ®é›†
            if (anomalyIndices.length > 0) {
                // åœ¨Z-Scoreæ›²çº¿ä¸Šæ ‡è®°å‡ºå¼‚å¸¸ç‚¹
                const anomalyData = zScores.map((z, i) => anomalyIndices.includes(i) ? z : null);
                
                datasets.push({
                    label: 'å•ç‚¹å¼‚å¸¸',
                    data: anomalyIndices.filter(i => anomalyTypes[i] === 'å•ç‚¹å¼‚å¸¸').map(i => zScores[i]),
                    pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    showLine: false,
                    pointStyle: 'circle'
                });
                
                datasets.push({
                    label: 'è¿ç»­æ€§å¼‚å¸¸',
                    data: anomalyIndices.filter(i => anomalyTypes[i] === 'è¿ç»­æ€§å¼‚å¸¸').map(i => zScores[i]),
                    pointBackgroundColor: 'rgba(255, 159, 64, 1)',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    showLine: false,
                    pointStyle: 'triangle'
                });
                
                datasets.push({
                    label: 'ç¾¤ä½“å¼‚å¸¸',
                    data: anomalyIndices.filter(i => anomalyTypes[i] === 'ç¾¤ä½“å¼‚å¸¸').map(i => zScores[i]),
                    pointBackgroundColor: 'rgba(153, 102, 255, 1)',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    showLine: false,
                    pointStyle: 'rect'
                });
            }
            
            // åˆ›å»ºå›¾è¡¨
            anomalyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true
                            }
                        },
                        annotation: {
                            annotations: {
                                anomalyThreshold: {
                                    type: 'line',
                                    yMin: 2,
                                    yMax: 2,
                                    borderColor: 'rgba(255, 0, 0, 0.5)',
                                    borderWidth: 2,
                                    borderDash: [6, 6],
                                    label: {
                                        display: true,
                                        content: 'å¼‚å¸¸é˜ˆå€¼ (Z-score = 2)',
                                        position: 'start'
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'æ•°æ®ç‚¹'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Z-Score'
                            }
                        }
                    }
                }
            });
            
            // å¦‚æœæ­£åœ¨æ¨¡æ‹Ÿäº‹ä»¶ï¼Œæ·»åŠ äº‹ä»¶åŒºåŸŸæ³¨é‡Š
            if (currentEventSimulation && currentEventSimulation !== bridgeEvents.NORMAL) {
                const eventName = eventSettings[currentEventSimulation].name;
                
                anomalyChart.options.plugins.annotation.annotations.eventRegion = {
                    type: 'box',
                    xMin: 0,
                    xMax: anomalyChart.data.labels.length - 1,
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderColor: 'rgba(255, 99, 132, 0.3)',
                    borderWidth: 1,
                    label: {
                        display: true,
                        content: `${eventName} å½±å“åŒºåŸŸ`,
                        position: 'start'
                    }
                };
                
                anomalyChart.update();
            }
        }

        // æ£€æµ‹å¼‚å¸¸
        function detectAnomalies() {
            if (!sensorData || sensorData.length === 0) {
                console.warn("æ²¡æœ‰æ•°æ®å¯ä¾›æ£€æµ‹");
                return {
                    totalPoints: 0,
                    anomalyCount: 0,
                    singlePointCount: 0,
                    continuousCount: 0,
                    clusterCount: 0,
                    anomalies: {}
                };
            }
            
            // æŒ‰ä¼ æ„Ÿå™¨åˆ†ç»„æ•°æ®
            const sensorGroups = {};
            
            sensorData.forEach(item => {
                if (!sensorGroups[item.sensorId]) {
                    sensorGroups[item.sensorId] = [];
                }
                sensorGroups[item.sensorId].push(item);
            });
            
            // ç”¨äºå­˜å‚¨æ¯ä¸ªä¼ æ„Ÿå™¨çš„å¼‚å¸¸ï¼ˆæŒ‰ç±»å‹åˆ†ç±»ï¼‰
            const anomaliesBySensor = {};
            
            // ç”¨äºZ-scoreå›¾è¡¨æ•°æ®
            zScores = [];
            anomalyIndices = [];
            anomalyTypes = [];
            
            // ç»Ÿè®¡æ•°æ®
            let totalDataPoints = 0;
            let totalAnomalies = 0;
            let singlePoints = 0;
            let continuousAnomalies = 0;
            let clusterAnomalies = 0;
            
            // å¯¹æ¯ä¸ªä¼ æ„Ÿå™¨è¿›è¡Œå¼‚å¸¸æ£€æµ‹
            for (const sensorId in sensorGroups) {
                const sensorDataPoints = sensorGroups[sensorId];
                
                // è·³è¿‡æ•°æ®é‡å¤ªå°‘çš„ä¼ æ„Ÿå™¨
                if (sensorDataPoints.length < 5) continue;
                
                // è®°å½•æ€»æ•°æ®ç‚¹æ•°
                totalDataPoints += sensorDataPoints.length;
                
                // æå–æ•°å€¼æ•°ç»„
                const values = sensorDataPoints.map(item => item.value);
                
                // è®¡ç®—åŸºæœ¬ç»Ÿè®¡é‡
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                
                // è®¡ç®—æ ‡å‡†å·®
                const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
                const stddev = Math.sqrt(variance);
                
                // å¦‚æœæ ‡å‡†å·®è¿‡å°ï¼Œå¯èƒ½è¡¨ç¤ºæ•°æ®å‡ ä¹æ²¡æœ‰æ³¢åŠ¨ï¼Œè¿™ç§æƒ…å†µä¸‹å¼‚å¸¸æ£€æµ‹å¯èƒ½ä¸é€‚ç”¨
                if (stddev < 0.001) continue;
                
                // è®¡ç®—Z-score
                const zScoreThreshold = 2.0; // æ ‡å‡†è®¾ç½®ä¸º2ï¼Œå¯¹åº”çº¦5%çš„å¼‚å¸¸ç‡
                const zScoreValues = values.map(value => Math.abs((value - mean) / stddev));
                
                // æ·»åŠ åˆ°Z-scoreé›†åˆç”¨äºå›¾è¡¨
                zScores = zScores.concat(zScoreValues);
                
                // æ£€æµ‹å¼‚å¸¸
                const currentSensorAnomalies = [];
                
                // åˆ¤æ–­ä¼ æ„Ÿå™¨ç±»å‹
                let sensorType = 'å…¶ä»–';
                if (sensorId.includes('æ¸©åº¦')) sensorType = 'æ¸©åº¦';
                else if (sensorId.includes('åº”å˜')) sensorType = 'åº”å˜';
                else if (sensorId.includes('æŒ¯åŠ¨')) sensorType = 'æŒ¯åŠ¨';
                else if (sensorId.includes('å€¾è§’')) sensorType = 'å€¾è§’';
                
                // å•ç‚¹å¼‚å¸¸æ£€æµ‹
                zScoreValues.forEach((zScore, index) => {
                    if (zScore > zScoreThreshold) {
                        // ç¡®å®šå¼‚å¸¸ç±»å‹
                        let anomalyType = 'å•ç‚¹å¼‚å¸¸';
                        
                        // æ£€æŸ¥æ˜¯å¦è¿ç»­å¼‚å¸¸
                        if (index > 0 && index < zScoreValues.length - 1) {
                            if (zScoreValues[index-1] > zScoreThreshold || zScoreValues[index+1] > zScoreThreshold) {
                                anomalyType = 'è¿ç»­æ€§å¼‚å¸¸';
                            }
                        }
                        
                        // æ·»åŠ å¼‚å¸¸è®°å½•
                        const dataPoint = sensorDataPoints[index];
                        currentSensorAnomalies.push({
                            sensorId: sensorId,
                            sensorType: sensorType,
                            timestamp: dataPoint.timestamp,
                            value: dataPoint.value,
                            zScore: zScore,
                            mean: mean,
                            stddev: stddev,
                            type: anomalyType
                        });
                        
                        // æ·»åŠ åˆ°å…¨å±€anomalyIndicesç”¨äºå›¾è¡¨
                        anomalyIndices.push(zScores.length - zScoreValues.length + index);
                        anomalyTypes.push(anomalyType);
                        
                        // ç»Ÿè®¡è®¡æ•°
                        totalAnomalies++;
                        if (anomalyType === 'å•ç‚¹å¼‚å¸¸') {
                            singlePoints++;
                        } else if (anomalyType === 'è¿ç»­æ€§å¼‚å¸¸') {
                            continuousAnomalies++;
                        }
                    }
                });
                
                // ç¾¤ä½“å¼‚å¸¸æ£€æµ‹ï¼ˆä½¿ç”¨æ»‘åŠ¨çª—å£æ£€æµ‹å¼‚å¸¸é›†ç¾¤ï¼‰
                const windowSize = 5; // æ»‘åŠ¨çª—å£å¤§å°
                for (let i = 0; i <= zScoreValues.length - windowSize; i++) {
                    const window = zScoreValues.slice(i, i + windowSize);
                    const windowMean = window.reduce((a, b) => a + b, 0) / windowSize;
                    
                    // å¦‚æœçª—å£å†…å¹³å‡Z-scoreè¶…è¿‡é˜ˆå€¼ï¼ˆä½†ä¸æ˜¯å› ä¸ºå•ä¸ªæç«¯å€¼å¼•èµ·çš„ï¼‰
                    if (windowMean > zScoreThreshold * 0.7 && window.filter(z => z > zScoreThreshold).length >= 2) {
                        // æ£€æŸ¥è¿™ä¸ªçª—å£æ˜¯å¦å·²ç»åŒ…å«äº†æ ‡è®°ä¸ºè¿ç»­æ€§å¼‚å¸¸çš„ç‚¹
                        const hasMarkedAnomaly = window.some((_, idx) => {
                            const globalIdx = zScores.length - zScoreValues.length + i + idx;
                            return anomalyIndices.includes(globalIdx);
                        });
                        
                        // å¦‚æœè¿™ä¸ªçª—å£æ²¡æœ‰è¢«æ ‡è®°è¿‡ï¼Œåˆ™æ ‡è®°ä¸ºç¾¤ä½“å¼‚å¸¸
                        if (!hasMarkedAnomaly) {
                            // å–çª—å£ä¸­é—´ç‚¹ä½œä¸ºä»£è¡¨
                            const midIdx = i + Math.floor(windowSize / 2);
                            const dataPoint = sensorDataPoints[midIdx];
                            
                            currentSensorAnomalies.push({
                                sensorId: sensorId,
                                sensorType: sensorType,
                                timestamp: dataPoint.timestamp,
                                value: dataPoint.value,
                                zScore: zScoreValues[midIdx],
                                mean: mean,
                                stddev: stddev,
                                type: 'ç¾¤ä½“å¼‚å¸¸'
                            });
                            
                            // æ·»åŠ åˆ°å…¨å±€indices
                            anomalyIndices.push(zScores.length - zScoreValues.length + midIdx);
                            anomalyTypes.push('ç¾¤ä½“å¼‚å¸¸');
                            
                            // ç»Ÿè®¡
                            totalAnomalies++;
                            clusterAnomalies++;
                        }
                    }
                }
                
                // ä¿å­˜å½“å‰ä¼ æ„Ÿå™¨çš„å¼‚å¸¸
                if (currentSensorAnomalies.length > 0) {
                    anomaliesBySensor[sensorId] = currentSensorAnomalies;
                }
            }
            
            // è¿”å›æ£€æµ‹ç»“æœ
            return {
                totalPoints: totalDataPoints,
                anomalyCount: totalAnomalies,
                singlePointCount: singlePoints,
                continuousCount: continuousAnomalies,
                clusterCount: clusterAnomalies,
                anomalies: anomaliesBySensor
            };
        }

        // ç”ŸæˆæŒ‰ä¼ æ„Ÿå™¨ç±»å‹åˆ†ç»„çš„å¼‚å¸¸åˆ—è¡¨
        function generateAnomalyList(anomaliesByType, sensorTypes) {
            anomalyList.innerHTML = '';  // ç¡®ä¿æ¸…ç©ºä¹‹å‰çš„åˆ—è¡¨
            
            const totalAnomalies = Object.values(anomaliesByType).reduce((sum, arr) => sum + arr.length, 0);
            
            if (totalAnomalies > 0) {
                // åˆ›å»ºç±»å‹é€‰æ‹©å™¨
                const typeSelector = document.createElement('div');
                typeSelector.className = 'anomaly-type-selector';
                typeSelector.style.marginBottom = '15px';
                typeSelector.style.display = 'flex';
                typeSelector.style.flexWrap = 'wrap';
                typeSelector.style.gap = '8px';
                
                // æ·»åŠ "å…¨éƒ¨"é€‰é¡¹
                const allTypesBtn = document.createElement('button');
                allTypesBtn.textContent = 'å…¨éƒ¨å¼‚å¸¸';
                allTypesBtn.className = 'anomaly-type-btn active';
                allTypesBtn.dataset.type = 'all';
                allTypesBtn.style.padding = '5px 12px';
                allTypesBtn.style.backgroundColor = '#4299e1';
                allTypesBtn.style.color = 'white';
                allTypesBtn.style.border = 'none';
                allTypesBtn.style.borderRadius = '4px';
                allTypesBtn.style.cursor = 'pointer';
                typeSelector.appendChild(allTypesBtn);
                
                // ä¸ºæ¯ç§ä¼ æ„Ÿå™¨ç±»å‹æ·»åŠ æŒ‰é’®
                sensorTypes.forEach(type => {
                    if (anomaliesByType[type].length > 0) {
                        const button = document.createElement('button');
                        button.textContent = `${type}ä¼ æ„Ÿå™¨ (${anomaliesByType[type].length})`;
                        button.className = 'anomaly-type-btn';
                        button.dataset.type = type;
                        button.style.padding = '5px 12px';
                        button.style.backgroundColor = '#e2e8f0';
                        button.style.border = 'none';
                        button.style.borderRadius = '4px';
                        button.style.cursor = 'pointer';
                        typeSelector.appendChild(button);
                    }
                });
                
                // æ·»åŠ æŒ‰é’®äº‹ä»¶ç›‘å¬
                typeSelector.addEventListener('click', function(e) {
                    if (e.target.classList.contains('anomaly-type-btn')) {
                        // æ›´æ–°æŒ‰é’®çŠ¶æ€
                        document.querySelectorAll('.anomaly-type-btn').forEach(btn => {
                            btn.classList.remove('active');
                            btn.style.backgroundColor = '#e2e8f0';
                            btn.style.color = 'black';
                        });
                        e.target.classList.add('active');
                        e.target.style.backgroundColor = '#4299e1';
                        e.target.style.color = 'white';
                        
                        // æ˜¾ç¤ºç›¸åº”ç±»å‹çš„å¼‚å¸¸
                        const type = e.target.dataset.type;
                        showAnomaliesByType(type, anomaliesByType, sensorTypes);
                    }
                });
                
                // æ·»åŠ ç±»å‹é€‰æ‹©å™¨åˆ°å¼‚å¸¸åˆ—è¡¨å‰
                anomalyList.parentNode.insertBefore(typeSelector, anomalyList);
                
                // é»˜è®¤æ˜¾ç¤ºæ‰€æœ‰å¼‚å¸¸
                showAnomaliesByType('all', anomaliesByType, sensorTypes);
            } else {
                // å¦‚æœæ²¡æœ‰å¼‚å¸¸ï¼Œæ˜¾ç¤ºä¸€æ¡ä¿¡æ¯
                const noAnomalyItem = document.createElement('li');
                noAnomalyItem.textContent = 'æœªæ£€æµ‹åˆ°ä»»ä½•å¼‚å¸¸æ•°æ®ç‚¹';
                noAnomalyItem.style.textAlign = 'center';
                noAnomalyItem.style.color = '#28a745';
                anomalyList.appendChild(noAnomalyItem);
            }
        }

        // æ˜¾ç¤ºæŒ‡å®šç±»å‹çš„å¼‚å¸¸
        function showAnomaliesByType(type, anomaliesByType, sensorTypes) {
            anomalyList.innerHTML = '';
            
            let anomaliesToShow = [];
            
            if (type === 'all') {
                // æ˜¾ç¤ºæ‰€æœ‰ç±»å‹çš„å¼‚å¸¸
                sensorTypes.forEach(t => {
                    if (anomaliesByType[t].length > 0) {
                        anomaliesToShow = anomaliesToShow.concat(anomaliesByType[t]);
                    }
                });
            } else {
                // æ˜¾ç¤ºç‰¹å®šç±»å‹çš„å¼‚å¸¸
                anomaliesToShow = anomaliesByType[type];
            }
            
            // æŒ‰ä¸¥é‡ç¨‹åº¦æ’åºï¼ˆZ-scoreé™åºï¼‰
            anomaliesToShow.sort((a, b) => b.zScore - a.zScore);
            
            // æ˜¾ç¤ºå¼‚å¸¸åˆ—è¡¨
            anomaliesToShow.forEach(anomaly => {
                const listItem = document.createElement('li');
                listItem.classList.add('anomaly-item');
                
                if (anomaly.zScore > 3.0) {
                    listItem.classList.add('severe');
                }
                
                // è·å–ä¼ æ„Ÿå™¨ç±»å‹å¯¹åº”çš„å•ä½
                let unit = '';
                if (anomaly.sensorType === 'æ¸©åº¦') unit = 'Â°C';
                else if (anomaly.sensorType === 'åº”å˜') unit = 'Î¼Îµ';
                else if (anomaly.sensorType === 'æŒ¯åŠ¨') unit = 'Hz';
                else if (anomaly.sensorType === 'å€¾è§’') unit = 'Â°';
                
                listItem.innerHTML = `
                    <strong>æ—¶é—´:</strong> ${anomaly.timestamp} | 
                    <strong>ä¼ æ„Ÿå™¨:</strong> <span class="sensor-type">${anomaly.sensorType}</span>: ${anomaly.sensorId} | 
                    <strong>æ•°å€¼:</strong> ${anomaly.value.toFixed(2)}${unit} | 
                    <strong>Zå¾—åˆ†:</strong> ${anomaly.zScore.toFixed(2)} | 
                    <strong>ç±»å‹:</strong> ${anomaly.type}
                `;
                
                // ä¸ºä¸åŒä¼ æ„Ÿå™¨ç±»å‹æ·»åŠ ä¸åŒçš„é¢œè‰²æ ‡è®°
                const sensorTypeSpan = listItem.querySelector('.sensor-type');
                if (sensorTypeSpan) {
                    if (anomaly.sensorType === 'æ¸©åº¦') {
                        sensorTypeSpan.style.color = '#e53e3e';
                    } else if (anomaly.sensorType === 'åº”å˜') {
                        sensorTypeSpan.style.color = '#3182ce';
                    } else if (anomaly.sensorType === 'æŒ¯åŠ¨') {
                        sensorTypeSpan.style.color = '#805ad5';
                    } else if (anomaly.sensorType === 'å€¾è§’') {
                        sensorTypeSpan.style.color = '#dd6b20';
                    }
                }
                
                anomalyList.appendChild(listItem);
            });
            
            // å¦‚æœç­›é€‰åæ²¡æœ‰å¼‚å¸¸ï¼Œæ˜¾ç¤ºæç¤º
            if (anomaliesToShow.length === 0) {
                const noFilteredItem = document.createElement('li');
                noFilteredItem.textContent = `æœªæ£€æµ‹åˆ°${type}ä¼ æ„Ÿå™¨çš„å¼‚å¸¸æ•°æ®ç‚¹`;
                noFilteredItem.style.textAlign = 'center';
                noFilteredItem.style.color = '#718096';
                anomalyList.appendChild(noFilteredItem);
            }
        }

        // åˆ›å»ºå¼‚å¸¸å›¾è¡¨æ§åˆ¶é¢æ¿
        function createAnomalyChartControls(sensorTypes, anomaliesByType, chart) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ§åˆ¶é¢æ¿
            let controlPanel = document.getElementById('anomaly-chart-controls');
            if (!controlPanel) {
                controlPanel = document.createElement('div');
                controlPanel.id = 'anomaly-chart-controls';
                controlPanel.className = 'chart-controls';
                controlPanel.style.marginBottom = '15px';
                controlPanel.style.display = 'flex';
                controlPanel.style.flexWrap = 'wrap';
                controlPanel.style.gap = '10px';
                
                const chartContainer = document.getElementById('anomaly-chart-container');
                chartContainer.insertBefore(controlPanel, document.getElementById('anomalyChart'));
            } else {
                controlPanel.innerHTML = ''; // æ¸…ç©ºç°æœ‰æ§ä»¶
            }
            
            // æ·»åŠ "å…¨éƒ¨æ˜¾ç¤º"æŒ‰é’®
            const showAllBtn = document.createElement('button');
            showAllBtn.textContent = 'æ˜¾ç¤ºå…¨éƒ¨';
            showAllBtn.className = 'chart-control-btn active';
            showAllBtn.style.padding = '5px 10px';
            showAllBtn.style.backgroundColor = '#4299e1';
            showAllBtn.style.color = 'white';
            showAllBtn.style.border = '1px solid #3182ce';
            showAllBtn.style.borderRadius = '4px';
            showAllBtn.style.cursor = 'pointer';
            
            showAllBtn.addEventListener('click', function() {
                if (chart) {
                    chart.data.datasets.forEach((dataset, index) => {
                        chart.setDatasetVisibility(index, true);
                    });
                    chart.update();
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    document.querySelectorAll('#anomaly-chart-controls .chart-control-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                }
            });
            
            controlPanel.appendChild(showAllBtn);
            
            // ä¸ºæ¯ç§ä¼ æ„Ÿå™¨ç±»å‹æ·»åŠ ç­›é€‰æŒ‰é’®
            sensorTypes.forEach(type => {
                if (anomaliesByType[type].length > 0) {
                    const button = document.createElement('button');
                    button.textContent = `${type}ä¼ æ„Ÿå™¨ (${anomaliesByType[type].length})`;
                    button.className = 'chart-control-btn';
                    button.style.padding = '5px 10px';
                    button.style.backgroundColor = '#e2e8f0';
                    button.style.border = '1px solid #cbd5e0';
                    button.style.borderRadius = '4px';
                    button.style.cursor = 'pointer';
                    
                    button.addEventListener('click', function() {
                        if (chart) {
                            // éšè—æ‰€æœ‰æ•°æ®é›†
                            chart.data.datasets.forEach((dataset, index) => {
                                const isCurrentType = dataset.label.includes(`${type}:`);
                                chart.setDatasetVisibility(index, isCurrentType);
                            });
                            chart.update();
                            
                            // æ›´æ–°æŒ‰é’®çŠ¶æ€
                            document.querySelectorAll('#anomaly-chart-controls .chart-control-btn').forEach(btn => {
                                btn.classList.remove('active');
                            });
                            this.classList.add('active');
                        }
                    });
                    
                    controlPanel.appendChild(button);
                }
            });
        }

        // é‡ç½®æ‰€æœ‰æ•°æ®å’ŒçŠ¶æ€
        function resetAll() {
            // é‡ç½®æ•°æ®
            sensorData = [];
            
            // é‡ç½®æ–‡ä»¶è¾“å…¥
            fileInput.value = '';
            fileInfo.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
            uploadButton.disabled = true;  // ç¡®ä¿æ£€æµ‹æŒ‰é’®åˆå§‹çŠ¶æ€ä¸ºç¦ç”¨
            
            // æ¸…é™¤è¡¨æ ¼æ•°æ®
            const tableBody = dataTable.getElementsByTagName('tbody')[0];
            tableBody.innerHTML = '';
            noDataMessage.style.display = 'block';
            
            // æ¸…é™¤å›¾è¡¨
            if (dataChart) {
                dataChart.destroy();
                dataChart = null;
            }
            noChartDataMessage.style.display = 'block';
            
            // æ¸…é™¤å¼‚å¸¸åˆ†æç»“æœ
            noAnalysisMessage.style.display = 'block';
            analysisLoader.style.display = 'none';
            analysisSummary.style.display = 'none';
            anomalyList.innerHTML = '';
            
            // éšè—æ¡¥æ¢ç›‘æ§
            noMonitorMessage.style.display = 'block';
            
            // åœæ­¢æ•°æ®æ›´æ–°
            stopDataUpdates();
            
            // åˆ‡æ¢åˆ°æ•°æ®æŸ¥çœ‹æ ‡ç­¾
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('.tab[data-tab="data"]').classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById('data-tab').classList.add('active');
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // ç”Ÿæˆç¤ºä¾‹æ•°æ®
        function createSampleData() {
            console.log("å¼€å§‹ç”Ÿæˆæ ·æœ¬æ•°æ®");
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const fileInfoElement = document.getElementById('fileInfo');
            if (fileInfoElement) {
                fileInfoElement.textContent = 'æ­£åœ¨ç”Ÿæˆç¤ºä¾‹æ•°æ®...';
            }
            
            // ç¦ç”¨æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
            const sampleBtnElement = document.getElementById('sampleButton');
            if (sampleBtnElement) {
                sampleBtnElement.disabled = true;
            }
            
            // é‡ç½®æ•°æ®
            sensorData = [];
            
            // æ£€æŸ¥è¡¨æ ¼å…ƒç´ æ˜¯å¦å­˜åœ¨
            const dataTable = document.getElementById('sensorDataTable');
            if (dataTable && dataTable.querySelector('tbody')) {
                dataTable.querySelector('tbody').innerHTML = '<tr><td colspan="5" class="text-center">æ­£åœ¨ç”Ÿæˆæ•°æ®ï¼Œè¯·ç¨å€™...</td></tr>';
            }
            
            // å®šä¹‰ä¼ æ„Ÿå™¨ç±»å‹å’Œä½ç½®
            const sensorTypes = [
                { type: 'æ¸©åº¦', count: 15, unit: 'Â°C' },
                { type: 'åº”å˜', count: 15, unit: 'Î¼Îµ' },
                { type: 'æŒ¯åŠ¨', count: 15, unit: 'Hz' },
                { type: 'å€¾è§’', count: 10, unit: 'Â°' },
                { type: 'ä½ç§»', count: 10, unit: 'mm' },
                { type: 'åŠ é€Ÿåº¦', count: 10, unit: 'm/sÂ²' },
                { type: 'è½½é‡', count: 5, unit: 'kN' },
                { type: 'é£é€Ÿ', count: 5, unit: 'm/s' },
                { type: 'å‹åŠ›', count: 5, unit: 'kPa' },
                { type: 'æ¹¿åº¦', count: 5, unit: '%' }
            ];
            
            const sections = ['åŒ—æ®µ', 'ä¸­æ®µ', 'å—æ®µ', 'ä¸œæ®µ', 'è¥¿æ®µ', 'æ”¯æ’‘ç»“æ„', 'è¿æ¥éƒ¨ä½'];
            const positions = ['æ¡¥é¢', 'æ¡¥å¢©', 'æ¡¥å¡”', 'åŠç´¢', 'æ”¯åº§', 'ä¼¸ç¼©ç¼', 'äº¤é€šç›‘æ§'];
            
            // å¼‚æ­¥å¤„ç†é¿å…ç•Œé¢å†»ç»“
            setTimeout(function() {
                try {
                    // åˆ›å»ºä¼ æ„Ÿå™¨æ•°æ®
                    let sensorId = 1;
                    
                    // ä¸ºæ¯ç§ä¼ æ„Ÿå™¨ç±»å‹ç”Ÿæˆæ ·æœ¬æ•°æ®
                    sensorTypes.forEach(sensor => {
                        for (let i = 0; i < sensor.count; i++) {
                            const section = sections[Math.floor(Math.random() * sections.length)];
                            const position = positions[Math.floor(Math.random() * positions.length)];
                            const sensorName = `${sensor.type}-${section}-${position}-${sensorId.toString().padStart(3, '0')}`;
                            
                            // æ ¹æ®ä¼ æ„Ÿå™¨ç±»å‹ç¡®å®šåŸºå‡†å€¼å’ŒèŒƒå›´
                            let baseValue, minValue, maxValue, warningThreshold, alarmThreshold;
                            
                            switch(sensor.type) {
                                case 'æ¸©åº¦':
                                    baseValue = 25;
                                    minValue = 5;
                                    maxValue = 55;
                                    warningThreshold = 40;
                                    alarmThreshold = 45;
                                    break;
                                case 'åº”å˜':
                                    baseValue = 200;
                                    minValue = 50;
                                    maxValue = 400;
                                    warningThreshold = 300;
                                    alarmThreshold = 350;
                                    break;
                                case 'æŒ¯åŠ¨':
                                    baseValue = 0.5;
                                    minValue = 0.05;
                                    maxValue = 3.0;
                                    warningThreshold = 1.5;
                                    alarmThreshold = 2.0;
                                    break;
                                case 'å€¾è§’':
                                    baseValue = 0.5;
                                    minValue = 0;
                                    maxValue = 3.0;
                                    warningThreshold = 1.5;
                                    alarmThreshold = 2.0;
                                    break;
                                case 'ä½ç§»':
                                    baseValue = 5;
                                    minValue = 0;
                                    maxValue = 30;
                                    warningThreshold = 15;
                                    alarmThreshold = 20;
                                    break;
                                case 'åŠ é€Ÿåº¦':
                                    baseValue = 0.2;
                                    minValue = 0;
                                    maxValue = 1.5;
                                    warningThreshold = 0.8;
                                    alarmThreshold = 1.0;
                                    break;
                                case 'è½½é‡':
                                    baseValue = 1000;
                                    minValue = 0;
                                    maxValue = 3000;
                                    warningThreshold = 2000;
                                    alarmThreshold = 2500;
                                    break;
                                case 'é£é€Ÿ':
                                    baseValue = 5;
                                    minValue = 0;
                                    maxValue = 30;
                                    warningThreshold = 18;
                                    alarmThreshold = 25;
                                    break;
                                case 'å‹åŠ›':
                                    baseValue = 100;
                                    minValue = 50;
                                    maxValue = 200;
                                    warningThreshold = 160;
                                    alarmThreshold = 180;
                                    break;
                                case 'æ¹¿åº¦':
                                    baseValue = 60;
                                    minValue = 20;
                                    maxValue = 95;
                                    warningThreshold = 85;
                                    alarmThreshold = 90;
                                    break;
                                default:
                                    baseValue = 50;
                                    minValue = 0;
                                    maxValue = 100;
                                    warningThreshold = 80;
                                    alarmThreshold = 90;
                            }
                            
                            // åˆ›å»ºæ—¶é—´æˆ³ï¼Œæ¯åŠå°æ—¶ä¸€ä¸ªæ•°æ®ç‚¹ï¼Œæœ€å¤šåˆ›å»º12å°æ—¶çš„æ•°æ®ï¼ˆ24ä¸ªç‚¹ï¼‰
                            const now = new Date();
                            const timestamps = [];
                            for (let t = 0; t < 24; t++) {
                                const timestamp = new Date(now.getTime() - (t * 30 * 60000));
                                timestamps.push(timestamp.toLocaleString('zh-CN', {
                                    year: 'numeric',
                                    month: '2-digit',
                                    day: '2-digit',
                                    hour: '2-digit',
                                    minute: '2-digit'
                                }));
                            }
                            
                            // ç”Ÿæˆæ•°æ®ç‚¹
                            for (let j = 0; j < timestamps.length; j++) {
                                // ä¸ºäº†æ¨¡æ‹ŸçœŸå®æ•°æ®ï¼Œæ ¹æ®æŸç§æ¨¡å¼ç”Ÿæˆæ•°æ®å€¼
                                let value;
                                if (sensor.type === 'æ¸©åº¦') {
                                    // æ¸©åº¦éšæ—¶é—´å‘ˆç°æ­£å¼¦æ³¢åŠ¨
                                    const hour = new Date(timestamps[j]).getHours();
                                    value = baseValue + 5 * Math.sin((hour / 24) * Math.PI * 2) + (Math.random() * 3 - 1.5);
                                } else if (sensor.type === 'é£é€Ÿ') {
                                    // é£é€Ÿåœ¨ç™½å¤©è¾ƒå¤§
                                    const hour = new Date(timestamps[j]).getHours();
                                    value = baseValue + 3 * Math.sin((hour / 24) * Math.PI) + (Math.random() * 2);
                                } else if (sensor.type === 'è½½é‡') {
                                    // è½½é‡åœ¨äº¤é€šé«˜å³°æœŸè¾ƒå¤§
                                    const hour = new Date(timestamps[j]).getHours();
                                    const trafficPeak = (hour >= 7 && hour <= 9) || (hour >= 17 && hour <= 19);
                                    value = baseValue + (trafficPeak ? 800 : 200) * Math.random();
                                } else {
                                    // å…¶ä»–ä¼ æ„Ÿå™¨æ•°æ®åŸºäºéšæœºæ³¢åŠ¨
                                    value = baseValue + (Math.random() * 2 - 1) * (maxValue - minValue) * 0.2;
                                }
                                
                                // å¼‚å¸¸æ¦‚ç‡
                                if (Math.random() < 0.2) { // å¢åŠ åˆ°20%çš„å¼‚å¸¸æ¦‚ç‡
                                    // ç”Ÿæˆå¼‚å¸¸æ•°æ®
                                    const anomalyDirection = Math.random() > 0.5 ? 1 : -1;
                                    const anomalyMagnitude = (Math.random() * 0.4 + 0.1) * (maxValue - minValue);
                                    value += anomalyDirection * anomalyMagnitude;
                                }
                                
                                // ç¡®ä¿å€¼åœ¨åˆç†èŒƒå›´å†…
                                value = Math.max(minValue, Math.min(maxValue, value));
                                
                                // ç¡®å®šä¼ æ„Ÿå™¨çŠ¶æ€
                                let status = 'normal';
                                if (value > warningThreshold && value < alarmThreshold) {
                                    status = 'warning';
                                } else if (value > alarmThreshold || value < minValue) {
                                    status = 'danger';
                                }
                                
                                // æ·»åŠ åˆ°æ•°æ®é›†
                                sensorData.push({
                                    timestamp: timestamps[j],
                                    sensorId: sensorName,
                                    value: parseFloat(value.toFixed(2)),
                                    status: status,
                                    sensorType: sensor.type,
                                    location: section,
                                    position: position,
                                    unit: sensor.unit
                                });
                            }
                            
                            sensorId++;
                        }
                    });
                    
                    // æ›´æ–°UI
                    displayData();
                    
                    // å¦‚æœå‡½æ•°å­˜åœ¨åˆ™è°ƒç”¨
                    if (typeof createChart === 'function') {
                        createChart();
                    }
                    
                    // åˆå§‹åŒ–æ¡¥æ¢çŠ¶æ€
                    if (typeof initBridgeMonitor === 'function') {
                        initBridgeMonitor();
                    }
                    
                    // åˆå§‹åŒ–äº‹ä»¶é¢„æµ‹
                    if (typeof initializeEventPredictions === 'function') {
                        initializeEventPredictions();
                    } else {
                        console.warn("initializeEventPredictions å‡½æ•°ä¸å­˜åœ¨");
                    }
                    
                    // ä½¿æ£€æµ‹æŒ‰é’®å¯ç”¨
                    const detectBtn = document.getElementById('detectButton');
                    if (detectBtn) {
                        detectBtn.disabled = false;
                    }
                    
                } catch (error) {
                    console.error("ç”Ÿæˆç¤ºä¾‹æ•°æ®æ—¶å‡ºé”™:", error);
                    if (fileInfoElement) {
                        fileInfoElement.textContent = `ç”Ÿæˆç¤ºä¾‹æ•°æ®å¤±è´¥: ${error.message}`;
                    }
                } finally {
                    // é‡æ–°å¯ç”¨æŒ‰é’®
                    const sampleBtn = document.getElementById('sampleButton');
                    if (sampleBtn) {
                        sampleBtn.disabled = false;
                    }
                }
            }, 10);
        }

        // ç”Ÿæˆå¹¶ä¸‹è½½ç¤ºä¾‹æ–‡ä»¶
        function generateExampleFile() {
            // é˜»æ­¢é»˜è®¤é“¾æ¥ç‚¹å‡»è¡Œä¸º
            event.preventDefault();
            
            // ç”Ÿæˆç¤ºä¾‹æ•°æ®
            const exampleData = [];
            const now = new Date();
            
            // æ·»åŠ è¡¨å¤´
            exampleData.push("æ—¶é—´æˆ³,ä¼ æ„Ÿå™¨ID,æ•°å€¼");
            
            // æ·»åŠ æ¸©åº¦ä¼ æ„Ÿå™¨æ•°æ®ç¤ºä¾‹
            for (let i = 0; i < 20; i++) {
                const timestamp = new Date(now.getTime() - (19-i) * 30 * 60 * 1000); // 30åˆ†é’Ÿé—´éš”
                const timeStr = timestamp.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                }).replace(',', ' ');
                
                // æ¸©åº¦å€¼(æ‘„æ°åº¦)ï¼Œçº¦25åº¦å·¦å³æ³¢åŠ¨
                let tempValue = 25 + Math.sin(i/3) * 2 + (Math.random() - 0.5);
                exampleData.push(`${timeStr},æ¸©åº¦ä¼ æ„Ÿå™¨-ä¸»æ¡¥åŒ—æ®µ,${tempValue.toFixed(2)}`);
            }
            
            // æ·»åŠ åº”å˜ä¼ æ„Ÿå™¨æ•°æ®ç¤ºä¾‹
            for (let i = 0; i < 20; i++) {
                const timestamp = new Date(now.getTime() - (19-i) * 30 * 60 * 1000); // 30åˆ†é’Ÿé—´éš”
                const timeStr = timestamp.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                }).replace(',', ' ');
                
                // åº”å˜å€¼(Î¼Îµ)ï¼Œçº¦200å·¦å³æ³¢åŠ¨
                let strainValue = 200 + Math.sin(i/4) * 15 + (Math.random() - 0.5) * 5;
                exampleData.push(`${timeStr},åº”å˜ä¼ æ„Ÿå™¨-ä¸»æ¡¥ä¸­æ®µ,${strainValue.toFixed(2)}`);
            }
            
            // æ·»åŠ æŒ¯åŠ¨ä¼ æ„Ÿå™¨æ•°æ®ç¤ºä¾‹
            for (let i = 0; i < 20; i++) {
                const timestamp = new Date(now.getTime() - (19-i) * 30 * 60 * 1000); // 30åˆ†é’Ÿé—´éš”
                const timeStr = timestamp.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                }).replace(',', ' ');
                
                // æŒ¯åŠ¨å€¼(g)ï¼Œçº¦0.5å·¦å³æ³¢åŠ¨
                let vibValue = 0.5 + Math.sin(i/2) * 0.1 + (Math.random() - 0.5) * 0.1;
                if (i === 10) vibValue = 1.2; // æ·»åŠ å¼‚å¸¸å€¼
                exampleData.push(`${timeStr},æŒ¯åŠ¨ä¼ æ„Ÿå™¨-ä¸»æ¡¥å—æ®µ,${vibValue.toFixed(2)}`);
            }
            
            // å°†ç¤ºä¾‹æ•°æ®è½¬æ¢ä¸ºCSVæ–‡æœ¬
            const csvContent = exampleData.join('\n');
            
            // åˆ›å»ºBlobå¯¹è±¡
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'æ¡¥æ¢ç›‘æµ‹æ•°æ®ç¤ºä¾‹.csv');
            link.style.visibility = 'hidden';
            
            // æ·»åŠ åˆ°DOMï¼Œè§¦å‘ä¸‹è½½ï¼Œç„¶åç§»é™¤
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // éšæœºåˆ·æ–°æ•°æ®åŠŸèƒ½
        function startRandomDataUpdates() {
            // åœæ­¢ä¹‹å‰çš„æ›´æ–°
            stopDataUpdates();
            
            // ç¡®ä¿æœ‰æ•°æ®
            if (!sensorData || sensorData.length === 0) {
                alert('è¯·å…ˆä¸Šä¼ æ•°æ®æˆ–ç”Ÿæˆç¤ºä¾‹æ•°æ®');
                return;
            }
            
            // æ˜¾ç¤ºæ­£åœ¨åˆ·æ–°æç¤º
            fileInfo.textContent = 'æ•°æ®åˆ·æ–°ä¸­...';
            refreshButton.textContent = 'åœæ­¢åˆ·æ–°';
            refreshButton.classList.add('danger');
            
            // å¯ç”¨æ£€æµ‹æŒ‰é’®ï¼Œç¡®ä¿åœ¨æ•°æ®åˆ·æ–°æ—¶å¯ä»¥è¿›è¡Œæ£€æµ‹
            detectButton.disabled = false;
            
            // æ¯5ç§’æ›´æ–°ä¸€æ¬¡æ•°æ®ï¼ˆæ›´ç¬¦åˆæ¡¥æ¢ç›‘æµ‹çš„å®é™…é¢‘ç‡ï¼‰
            dataUpdateInterval = setInterval(() => {
                randomlyUpdateData();
            }, 5000);
        }
        
        // åœæ­¢æ•°æ®æ›´æ–°
        function stopDataUpdates() {
            if (dataUpdateInterval) {
                clearInterval(dataUpdateInterval);
                dataUpdateInterval = null;
                
                refreshButton.textContent = 'éšæœºåˆ·æ–°æ•°æ®';
                refreshButton.classList.remove('danger');
                
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    fileInfo.textContent = `å·²é€‰æ‹©æ–‡ä»¶: ${file.name} (${formatFileSize(file.size)})`;
                } else {
                    fileInfo.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                }
            }
        }
        
        // éšæœºæ›´æ–°æ•°æ®ï¼Œä½¿æ¨¡æ‹Ÿæ•°æ®æ›´ç¬¦åˆç‰©ç†ç°å®å¹¶æ·»åŠ äº‹ä»¶
        function randomlyUpdateData() {
            if (!sensorData || sensorData.length === 0) return;
            
            // è·å–å½“å‰æ—¶é—´ä½œä¸ºæ–°çš„æ•°æ®ç‚¹æ—¶é—´æˆ³
            const now = new Date();
            const timeStr = now.toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // è·å–å”¯ä¸€çš„ä¼ æ„Ÿå™¨IDåˆ—è¡¨
            const uniqueSensors = [...new Set(sensorData.map(item => item.sensorId))];
            
            // åˆ›å»ºç¯å¢ƒå› ç´ ï¼Œç¡®ä¿æ•°æ®ä¹‹é—´çš„å…³è”æ€§
            const environmentalFactor = Math.sin(Date.now() / 10000000) * 0.15; // ç¼“æ…¢å˜åŒ–çš„ç¯å¢ƒå› ç´ 
            const timeOfDayFactor = Math.sin(now.getHours() / 24 * Math.PI) * 0.1; // æ—¥é—´å˜åŒ–å› ç´ 
            const bridgeLoadFactor = Math.sin(Date.now() / 3600000) * 0.08; // æ¡¥æ¢è´Ÿè½½å˜åŒ–
            
            // å…¨å±€æ¸©åº¦å½±å“
            const temperature = 20 + Math.sin(now.getHours() / 24 * Math.PI * 2) * 5 + Math.random() * 2;
            
            // éšæœºç”Ÿæˆäº‹ä»¶
            let currentEvent = null;
            const eventProbability = Math.random();
            let eventImpact = 0;
            let eventLocation = '';
            let eventSeverity = 'low';
            let affectedSensorTypes = [];
            let affectedSections = [];
            let eventReasoning = 'æ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®åœ¨æ­£å¸¸èŒƒå›´å†…ï¼Œæ— å¼‚å¸¸æ¨¡å¼';
            
            // å®šä¹‰å¯èƒ½çš„äº‹ä»¶ç±»å‹
            const possibleEvents = [
                {
                    type: 'æ­£å¸¸è¿ç»´ä¸­',
                    probability: 0.80, // 80%æ¦‚ç‡æ­£å¸¸è¿è¡Œ
                    impact: 0,
                    severity: 'low',
                    affectedTypes: [],
                    affectedSections: []
                },
                {
                    type: 'äº¤é€šè´Ÿè½½è¿‡é«˜',
                    probability: 0.05, // 5%æ¦‚ç‡
                    impact: 0.4,
                    severity: 'medium',
                    affectedTypes: ['åº”å˜', 'æŒ¯åŠ¨', 'è½½é‡'],
                    affectedSections: ['ä¸­æ®µ', 'åŒ—æ®µ']
                },
                {
                    type: 'ç»“æ„åº”å˜å¼‚å¸¸',
                    probability: 0.03, // 3%æ¦‚ç‡
                    impact: 0.6,
                    severity: 'high',
                    affectedTypes: ['åº”å˜', 'ä½ç§»', 'å€¾è§’'],
                    affectedSections: ['å—æ®µ', 'æ”¯æ’‘ç»“æ„']
                },
                {
                    type: 'æ¸©åº¦å¼‚å¸¸æ³¢åŠ¨',
                    probability: 0.04, // 4%æ¦‚ç‡
                    impact: 0.3,
                    severity: 'medium',
                    affectedTypes: ['æ¸©åº¦', 'åº”å˜'],
                    affectedSections: ['å…¨æ¡¥']
                },
                {
                    type: 'å¤–éƒ¨éœ‡åŠ¨å¹²æ‰°',
                    probability: 0.03, // 3%æ¦‚ç‡
                    impact: 0.5,
                    severity: 'medium',
                    affectedTypes: ['æŒ¯åŠ¨', 'åŠ é€Ÿåº¦'],
                    affectedSections: ['ä¸œæ®µ', 'è¥¿æ®µ']
                },
                {
                    type: 'é£åŠ›å½±å“æ˜æ˜¾',
                    probability: 0.03, // 3%æ¦‚ç‡
                    impact: 0.35,
                    severity: 'low',
                    affectedTypes: ['æŒ¯åŠ¨', 'å€¾è§’'],
                    affectedSections: ['å…¨æ¡¥']
                },
                {
                    type: 'æ”¯åº§ä½ç§»å¼‚å¸¸',
                    probability: 0.01, // 1%æ¦‚ç‡
                    impact: 0.7,
                    severity: 'high',
                    affectedTypes: ['ä½ç§»', 'åº”å˜', 'å€¾è§’'],
                    affectedSections: ['è¿æ¥éƒ¨ä½', 'æ”¯æ’‘ç»“æ„']
                },
                {
                    type: 'åŠç´¢å¼ åŠ›å˜åŒ–',
                    probability: 0.01, // 1%æ¦‚ç‡
                    impact: 0.5,
                    severity: 'medium',
                    affectedTypes: ['åº”å˜', 'åŠ é€Ÿåº¦'],
                    affectedSections: ['è¿æ¥éƒ¨ä½']
                }
            ];
            
            // ç´¯ç§¯æ¦‚ç‡ç¡®å®šäº‹ä»¶
            let cumulativeProbability = 0;
            for (const event of possibleEvents) {
                cumulativeProbability += event.probability;
                if (eventProbability <= cumulativeProbability) {
                    currentEvent = event;
                    eventImpact = event.impact;
                    eventSeverity = event.severity;
                    affectedSensorTypes = event.affectedTypes;
                    
                    // ç¡®å®šå½±å“åŒºæ®µ
                    if (event.affectedSections.includes('å…¨æ¡¥')) {
                        affectedSections = ['åŒ—æ®µ', 'ä¸­æ®µ', 'å—æ®µ', 'ä¸œæ®µ', 'è¥¿æ®µ', 'æ”¯æ’‘ç»“æ„', 'è¿æ¥éƒ¨ä½'];
                    } else {
                        affectedSections = event.affectedSections;
                    }
                    
                    // ä¸ºä¸åŒäº‹ä»¶ç±»å‹ç”Ÿæˆä¸åŒçš„åˆ¤æ–­ä¾æ®
                    switch (event.type) {
                        case 'äº¤é€šè´Ÿè½½è¿‡é«˜':
                            eventReasoning = 'ä¸­æ®µè½½é‡ä¼ æ„Ÿå™¨æ•°æ®æŒç»­åé«˜ï¼ŒæŒ¯åŠ¨é¢‘ç‡å¢åŠ ï¼Œä¸äº¤é€šé«˜å³°æœŸæ¨¡å¼åŒ¹é…';
                            break;
                        case 'ç»“æ„åº”å˜å¼‚å¸¸':
                            eventReasoning = 'å—æ®µåº”å˜ä¼ æ„Ÿå™¨å’Œæ”¯æ’‘ç»“æ„ä½ç§»æ•°æ®å¼‚å¸¸ï¼Œä¸å†å²åº”å˜æ¨¡å¼ä¸ç¬¦';
                            break;
                        case 'æ¸©åº¦å¼‚å¸¸æ³¢åŠ¨':
                            eventReasoning = 'å…¨æ¡¥æ¸©åº¦ä¼ æ„Ÿå™¨æ•°æ®å‡ºç°éæ­£å¸¸æ¸©åº¦å˜åŒ–ï¼Œè¶…å‡ºå­£èŠ‚æ€§é¢„æœŸèŒƒå›´';
                            break;
                        case 'å¤–éƒ¨éœ‡åŠ¨å¹²æ‰°':
                            eventReasoning = 'ä¸œè¥¿ä¸¤æ®µåŠ é€Ÿåº¦å’ŒæŒ¯åŠ¨ä¼ æ„Ÿå™¨æ£€æµ‹åˆ°å¼‚å¸¸éœ‡åŠ¨æ¨¡å¼ï¼Œå¯èƒ½å—å¤–éƒ¨å·¥ç¨‹å½±å“';
                            break;
                        case 'é£åŠ›å½±å“æ˜æ˜¾':
                            eventReasoning = 'å…¨æ¡¥æŒ¯åŠ¨å’Œå€¾è§’ä¼ æ„Ÿå™¨æ•°æ®æ³¢åŠ¨å¢å¤§ï¼Œä¸æ°”è±¡ç«™é£é€Ÿæ•°æ®ç›¸å…³';
                            break;
                        case 'æ”¯åº§ä½ç§»å¼‚å¸¸':
                            eventReasoning = 'è¿æ¥éƒ¨ä½ä½ç§»ä¼ æ„Ÿå™¨æ•°æ®çªå˜ï¼Œæ”¯æ’‘ç»“æ„å€¾è§’å˜åŒ–æ˜¾è‘—';
                            break;
                        case 'åŠç´¢å¼ åŠ›å˜åŒ–':
                            eventReasoning = 'è¿æ¥éƒ¨ä½åŠç´¢åº”å˜å’ŒåŠ é€Ÿåº¦ä¼ æ„Ÿå™¨æ•°æ®æ³¢åŠ¨å¼‚å¸¸ï¼Œå¯èƒ½éœ€è¦æ£€æŸ¥åŠç´¢å¼ åŠ›';
                            break;
                        default:
                            eventReasoning = 'æ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®åœ¨æ­£å¸¸èŒƒå›´å†…ï¼Œæ— å¼‚å¸¸æ¨¡å¼';
                    }
                    
                    break;
                }
            }
            
            // æ›´æ–°äº‹ä»¶é¢„æµ‹
            if (currentEvent && currentEvent.type !== 'æ­£å¸¸è¿ç»´ä¸­') {
                // æ¸…é™¤æ—§é¢„æµ‹
                eventPredictions.length = 0;
                
                // æ·»åŠ æ–°é¢„æµ‹
                eventPredictions.push({
                    id: Date.now(),
                    eventType: currentEvent.type,
                    probability: 0.5 + Math.random() * 0.4, // 50%-90%æ¦‚ç‡
                    reasoning: eventReasoning,
                    timestamp: timeStr,
                    severity: eventSeverity,
                    relatedSensors: generateAffectedSensorList(affectedSensorTypes, affectedSections)
                });
                
                // æ˜¾ç¤ºäº‹ä»¶é¢„æµ‹
                displayEventPredictions();
            } else if (Math.random() > 0.9) { // 10%çš„æ¦‚ç‡æ›´æ–°æ­£å¸¸è¿è¡ŒçŠ¶æ€
                eventPredictions.length = 0;
                eventPredictions.push({
                    id: Date.now(),
                    eventType: 'æ­£å¸¸è¿ç»´ä¸­',
                    probability: 0.9 + Math.random() * 0.09, // 90%-99%æ¦‚ç‡
                    reasoning: 'æ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®åœ¨æ­£å¸¸èŒƒå›´å†…ï¼Œæ— å¼‚å¸¸æ¨¡å¼',
                    timestamp: timeStr,
                    severity: 'low',
                    relatedSensors: ['ç³»ç»ŸçŠ¶æ€', 'æ‰€æœ‰ä¼ æ„Ÿå™¨']
                });
                displayEventPredictions();
            }
            
            // ä¸ºæ¯ä¸ªä¼ æ„Ÿå™¨åˆ›å»ºæ–°çš„æ•°æ®ç‚¹
            uniqueSensors.forEach(sensorId => {
                // è·å–è¯¥ä¼ æ„Ÿå™¨çš„å†å²æ•°æ®
                const sensorPoints = sensorData.filter(item => item.sensorId === sensorId);
                if (sensorPoints.length === 0) return;
                
                const currentSensor = sensorPoints[sensorPoints.length - 1];
                const currentValue = currentSensor.value;
                
                // æ ¹æ®ä¼ æ„Ÿå™¨IDåˆ†æä¼ æ„Ÿå™¨ç±»å‹å’ŒåŒºæ®µ
                let sensorType = currentSensor.sensorType || 'å…¶ä»–';
                let sensorLocation = currentSensor.location || 'ä¸­æ®µ';
                
                // ç¡®å®šæ˜¯å¦å—å½“å‰äº‹ä»¶å½±å“
                const isAffectedType = affectedSensorTypes.includes(sensorType);
                const isAffectedSection = affectedSections.includes(sensorLocation);
                const isAffected = isAffectedType && isAffectedSection;
                
                // æ ¹æ®ä¼ æ„Ÿå™¨ç±»å‹è·å–æ•°æ®èŒƒå›´
                let baseValue, minValue, maxValue, warningThreshold, alarmThreshold;
                
                switch(sensorType) {
                    case 'æ¸©åº¦':
                        baseValue = 25;
                        minValue = 5;
                        maxValue = 55;
                        warningThreshold = 40;
                        alarmThreshold = 45;
                        break;
                    case 'åº”å˜':
                        baseValue = 200;
                        minValue = 50;
                        maxValue = 400;
                        warningThreshold = 300;
                        alarmThreshold = 350;
                        break;
                    case 'æŒ¯åŠ¨':
                        baseValue = 0.5;
                        minValue = 0.05;
                        maxValue = 3.0;
                        warningThreshold = 1.5;
                        alarmThreshold = 2.0;
                        break;
                    case 'å€¾è§’':
                        baseValue = 0.5;
                        minValue = 0;
                        maxValue = 3.0;
                        warningThreshold = 1.5;
                        alarmThreshold = 2.0;
                        break;
                    case 'ä½ç§»':
                        baseValue = 5;
                        minValue = 0;
                        maxValue = 30;
                        warningThreshold = 15;
                        alarmThreshold = 20;
                        break;
                    case 'åŠ é€Ÿåº¦':
                        baseValue = 0.2;
                        minValue = 0;
                        maxValue = 1.5;
                        warningThreshold = 0.8;
                        alarmThreshold = 1.0;
                        break;
                    case 'è½½é‡':
                        baseValue = 1000;
                        minValue = 0;
                        maxValue = 3000;
                        warningThreshold = 2000;
                        alarmThreshold = 2500;
                        break;
                    default:
                        baseValue = 50;
                        minValue = 0;
                        maxValue = 100;
                        warningThreshold = 80;
                        alarmThreshold = 90;
                }
                
                // è®¡ç®—åŸºç¡€å˜åŒ–é‡
                const randomFactor = (Math.random() * 2 - 1) * 0.01 * currentValue; // åŸºç¡€éšæœºæ³¢åŠ¨ (å°å¹…)
                
                // ç¯å¢ƒå› ç´ å½±å“
                let environmentalImpact = 0;
                if (sensorType === 'æ¸©åº¦') {
                    environmentalImpact = environmentalFactor * 1.2 + (temperature - 20) * 0.1;
                } else if (sensorType === 'åº”å˜') {
                    environmentalImpact = bridgeLoadFactor * 1.5 + timeOfDayFactor * 0.5;
                } else if (sensorType === 'æŒ¯åŠ¨') {
                    environmentalImpact = bridgeLoadFactor * 1.2 + environmentalFactor * 0.8;
                } else if (sensorType === 'å€¾è§’') {
                    environmentalImpact = bridgeLoadFactor * 0.9 + environmentalFactor * 1.1;
                } else if (sensorType === 'ä½ç§»') {
                    environmentalImpact = bridgeLoadFactor * 1.3 + environmentalFactor * 0.7;
                } else if (sensorType === 'åŠ é€Ÿåº¦') {
                    environmentalImpact = bridgeLoadFactor * 1.4 + environmentalFactor * 1.2;
                } else if (sensorType === 'è½½é‡') {
                    environmentalImpact = bridgeLoadFactor * 2.0 + timeOfDayFactor * 1.5;
                } else {
                    environmentalImpact = environmentalFactor * 0.8 + timeOfDayFactor * 0.7;
                }
                
                // äº‹ä»¶å½±å“
                let eventEffect = 0;
                if (isAffected) {
                    // äº‹ä»¶å½±å“æ ¹æ®ä¼ æ„Ÿå™¨ç±»å‹ä¸åŒè€Œä¸åŒ
                    let typeMultiplier = 1.0;
                    if (currentEvent) {
                        switch(currentEvent.type) {
                            case 'äº¤é€šè´Ÿè½½è¿‡é«˜':
                                if (sensorType === 'è½½é‡') typeMultiplier = 2.0;
                                else if (sensorType === 'æŒ¯åŠ¨') typeMultiplier = 1.5;
                                else if (sensorType === 'åº”å˜') typeMultiplier = 1.3;
                                break;
                            case 'ç»“æ„åº”å˜å¼‚å¸¸':
                                if (sensorType === 'åº”å˜') typeMultiplier = 2.0;
                                else if (sensorType === 'ä½ç§»') typeMultiplier = 1.8;
                                else if (sensorType === 'å€¾è§’') typeMultiplier = 1.5;
                                break;
                            case 'æ¸©åº¦å¼‚å¸¸æ³¢åŠ¨':
                                if (sensorType === 'æ¸©åº¦') typeMultiplier = 1.8;
                                else if (sensorType === 'åº”å˜') typeMultiplier = 1.2;
                                break;
                            case 'å¤–éƒ¨éœ‡åŠ¨å¹²æ‰°':
                                if (sensorType === 'æŒ¯åŠ¨') typeMultiplier = 2.0;
                                else if (sensorType === 'åŠ é€Ÿåº¦') typeMultiplier = 1.8;
                                break;
                            case 'é£åŠ›å½±å“æ˜æ˜¾':
                                if (sensorType === 'æŒ¯åŠ¨') typeMultiplier = 1.5;
                                else if (sensorType === 'å€¾è§’') typeMultiplier = 1.3;
                                break;
                            case 'æ”¯åº§ä½ç§»å¼‚å¸¸':
                                if (sensorType === 'ä½ç§»') typeMultiplier = 2.2;
                                else if (sensorType === 'åº”å˜') typeMultiplier = 1.5;
                                else if (sensorType === 'å€¾è§’') typeMultiplier = 1.7;
                                break;
                            case 'åŠç´¢å¼ åŠ›å˜åŒ–':
                                if (sensorType === 'åº”å˜') typeMultiplier = 1.8;
                                else if (sensorType === 'åŠ é€Ÿåº¦') typeMultiplier = 1.6;
                                break;
                        }
                    }
                    
                    // è®¡ç®—äº‹ä»¶å½±å“
                    const directionFactor = eventImpact * typeMultiplier;
                    const randomDirection = Math.random() > 0.3; // 70%æ¦‚ç‡ä¸ºæ­£å‘å˜åŒ–
                    eventEffect = (randomDirection ? 1 : -1) * directionFactor * baseValue * 0.2;
                }
                
                // å¼‚å¸¸æ¦‚ç‡(éšæœºå¼‚å¸¸ã€ä¸å—äº‹ä»¶å½±å“)
                let anomalyEffect = 0;
                if (!isAffected && Math.random() < 0.05) { // 5%æ¦‚ç‡äº§ç”Ÿéšæœºå¼‚å¸¸
                    anomalyEffect = (Math.random() < 0.5 ? 1 : -1) * Math.random() * 0.3 * baseValue;
                }
                
                // åŸºç¡€ç¯å¢ƒå½±å“
                let baseChange = (environmentalImpact * currentValue * 0.05) + randomFactor;
                
                // è®¡ç®—æ€»å˜åŒ–é‡
                let totalChange = baseChange + eventEffect + anomalyEffect;
                
                // è®¡ç®—æ–°å€¼
                let newValue = currentValue + totalChange;
                
                // ç¡®ä¿æ–°å€¼åœ¨åˆç†èŒƒå›´å†…
                newValue = Math.max(minValue, Math.min(maxValue, newValue));
                
                // ç¡®ä¿æ•°æ®çš„è¿ç»­æ€§
                const maxChange = currentValue * 0.25; // æœ€å¤§å…è®¸25%çš„å˜åŒ–
                if (Math.abs(newValue - currentValue) > maxChange) {
                    newValue = currentValue + (Math.sign(newValue - currentValue) * maxChange * Math.random());
                }
                
                // ç¡®å®šä¼ æ„Ÿå™¨çŠ¶æ€
                let status = 'normal';
                if (newValue > warningThreshold && newValue < alarmThreshold) {
                    status = 'warning';
                }
                if (newValue > alarmThreshold || newValue < minValue) {
                    status = 'danger';
                }
                
                // åˆ›å»ºæ–°çš„æ•°æ®ç‚¹
                const newDataPoint = {
                    timestamp: timeStr,
                    sensorId: sensorId,
                    value: newValue,
                    status: status,
                    sensorType: sensorType,
                    location: sensorLocation
                };
                
                // æ·»åŠ åˆ°æ•°æ®é›†
                sensorData.push(newDataPoint);
                
                // æ›´æ–°UI
                addDataToTable(newDataPoint);
                
                // æ›´æ–°å›¾è¡¨
                updateCharts();
                
                // æ›´æ–°ç›¸å…³æ‘„åƒå¤´çŠ¶æ€
                updateCameraStatus(sensorId, status);
            });
            
            // é™åˆ¶æ•°æ®ç‚¹æ•°é‡ï¼Œä¿ç•™æœ€è¿‘çš„2000ä¸ªæ•°æ®ç‚¹
            if (sensorData.length > 2000) {
                sensorData = sensorData.slice(sensorData.length - 2000);
                refreshTable();
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®ä¼ æ„Ÿå™¨ç±»å‹å’ŒåŒºæ®µç”Ÿæˆå—å½±å“çš„ä¼ æ„Ÿå™¨åˆ—è¡¨
        function generateAffectedSensorList(types, sections) {
            if (types.length === 0 || sections.length === 0) {
                return ['ç³»ç»ŸçŠ¶æ€'];
            }
            
            // ä»ç°æœ‰ä¼ æ„Ÿå™¨ä¸­æ‰¾å‡ºå—å½±å“çš„ä¼ æ„Ÿå™¨ID
            const affectedSensors = [];
            const sensorsByType = {};
            
            // æŒ‰ç±»å‹åˆ†ç»„ä¼ æ„Ÿå™¨
            sensorData.forEach(item => {
                if (!sensorsByType[item.sensorType]) {
                    sensorsByType[item.sensorType] = new Set();
                }
                sensorsByType[item.sensorType].add(item.sensorId);
            });
            
            // ä¸ºæ¯ç§ç±»å‹æ‰¾å‡ºæœ€å¤š3ä¸ªä¼ æ„Ÿå™¨
            types.forEach(type => {
                if (sensorsByType[type]) {
                    // è½¬ä¸ºæ•°ç»„å¹¶ç­›é€‰ç¬¦åˆåŒºæ®µçš„ä¼ æ„Ÿå™¨
                    const sensors = Array.from(sensorsByType[type]).filter(id => {
                        const sensorPoint = sensorData.find(s => s.sensorId === id);
                        return sensorPoint && sections.includes(sensorPoint.location);
                    });
                    
                    // éšæœºé€‰æ‹©æœ€å¤š3ä¸ªä¼ æ„Ÿå™¨
                    const selectedCount = Math.min(3, sensors.length);
                    for (let i = 0; i < selectedCount; i++) {
                        const randomIndex = Math.floor(Math.random() * sensors.length);
                        if (sensors[randomIndex] && !affectedSensors.includes(sensors[randomIndex])) {
                            affectedSensors.push(sensors[randomIndex]);
                            sensors.splice(randomIndex, 1);
                        }
                    }
                }
            });
            
            return affectedSensors.length > 0 ? affectedSensors : ['ç³»ç»ŸçŠ¶æ€'];
        }

        // æ‘„åƒå¤´æ•°æ®ç”Ÿæˆ
        function generateCameras() {
            allCameras = [];
            const sections = ['åŒ—æ®µ', 'ä¸­æ®µ', 'å—æ®µ', 'ä¸œæ®µ', 'è¥¿æ®µ', 'æ”¯æ’‘ç»“æ„', 'è¿æ¥éƒ¨ä½'];
            const positions = ['æ¡¥é¢', 'æ¡¥å¢©', 'æ¡¥å¡”', 'åŠç´¢', 'æ”¯åº§', 'ä¼¸ç¼©ç¼', 'äº¤é€šç›‘æ§'];
            
            // æ”¶é›†ç°æœ‰ä¼ æ„Ÿå™¨ID
            const existingSensorIds = new Set(sensorData.map(item => item.sensorId));
            
            // ä¸ºæ¯ä¸ªä¼ æ„Ÿå™¨åˆ›å»ºå…³è”æ‘„åƒå¤´
            let cameraCount = 0;
            existingSensorIds.forEach(sensorId => {
                // åˆ¤æ–­ä¼ æ„Ÿå™¨ä½ç½®
                let section = 'ä¸­æ®µ';
                let position = 'æ¡¥é¢';
                
                for (const s of sections) {
                    if (sensorId.includes(s)) {
                        section = s;
                        break;
                    }
                }
                
                for (const p of positions) {
                    if (sensorId.includes(p)) {
                        position = p;
                        break;
                    }
                }
                
                // åˆ›å»ºæ‘„åƒå¤´
                const statusChance = Math.random();
                let status;
                
                if (statusChance > 0.9) {
                    status = 'offline';
                } else if (statusChance > 0.8) {
                    status = 'warning';
                } else {
                    status = 'online';
                }
                
                cameraCount++;
                allCameras.push({
                    id: `CAM-${cameraCount.toString().padStart(3, '0')}`,
                    name: `${section}${position}æ‘„åƒå¤´-${cameraCount}`,
                    status: status,
                    sensorId: sensorId,
                    section: section,
                    position: position,
                    lastUpdate: new Date(Date.now() - Math.floor(Math.random() * 3600000)).toLocaleString('zh-CN')
                });
            });
            
            // å¦‚æœæ‘„åƒå¤´æ•°é‡ä¸è¶³50ä¸ªï¼Œæ·»åŠ é¢å¤–çš„æ‘„åƒå¤´
            while (allCameras.length < 50) {
                cameraCount++;
                const section = sections[Math.floor(Math.random() * sections.length)];
                const position = positions[Math.floor(Math.random() * positions.length)];
                const statusChance = Math.random();
                let status;
                
                if (statusChance > 0.9) {
                    status = 'offline';
                } else if (statusChance > 0.8) {
                    status = 'warning';
                } else {
                    status = 'online';
                }
                
                allCameras.push({
                    id: `CAM-${cameraCount.toString().padStart(3, '0')}`,
                    name: `${section}${position}æ‘„åƒå¤´-${cameraCount}`,
                    status: status,
                    sensorId: `ä¼ æ„Ÿå™¨-${section}-${position}-${cameraCount.toString().padStart(2, '0')}`,
                    section: section,
                    position: position,
                    lastUpdate: new Date(Date.now() - Math.floor(Math.random() * 3600000)).toLocaleString('zh-CN')
                });
            }
            
            return allCameras;
        }

        // æ·»åŠ ç¤ºä¾‹æ•°æ®æŒ‰é’®å’Œä¸‹è½½ç¤ºä¾‹æ–‡ä»¶åŠŸèƒ½
        document.getElementById('sampleButton').addEventListener('click', function() {
            // ç”Ÿæˆç¤ºä¾‹æ•°æ®
            createSampleData();
            
            // ç¡®ä¿æ£€æµ‹æŒ‰é’®å¯ç”¨
            document.getElementById('detectButton').disabled = false;
        });
        downloadExample.addEventListener('click', generateExampleFile);
        
        // éšæœºåˆ·æ–°æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        refreshButton.addEventListener('click', function() {
            if (dataUpdateInterval) {
                stopDataUpdates();
            } else {
                startRandomDataUpdates();
            }
        });
        
        // åˆå§‹åŒ–
        resetAll();
        // æ£€æŸ¥ç™»å½•çŠ¶æ€
        checkLoginStatus();
        // åˆå§‹åŒ–äº‹ä»¶æ§åˆ¶é¢æ¿
        initEventControls();

        // ç¡®å®šå¼‚å¸¸ç±»å‹
        function determineAnomalyType(index, values, zScore) {
            try {
                // æ£€æŸ¥å‰åæ˜¯å¦ä¹Ÿæ˜¯å¼‚å¸¸ï¼Œåˆ¤æ–­è¿ç»­æ€§å¼‚å¸¸
                let isContinuous = false;
                
                if (index > 1) {  // ç¡®ä¿æœ‰å‰ä¸¤ä¸ªç‚¹
                    try {
                        isContinuous = Math.abs((values[index-1] - values[index-2]) / Math.max(0.01, Math.abs(values[index-2]))) > 0.1;
                    } catch (e) {
                        console.warn("è®¡ç®—å‰å¯¼ç‚¹è¿ç»­æ€§å¼‚å¸¸æ—¶å‡ºé”™:", e.message);
                    }
                }
                
                if (!isContinuous && index < values.length - 1) {  // æ£€æŸ¥åä¸€ä¸ªç‚¹
                    try {
                        isContinuous = Math.abs((values[index+1] - values[index]) / Math.max(0.01, Math.abs(values[index]))) > 0.1;
                    } catch (e) {
                        console.warn("è®¡ç®—åç»§ç‚¹è¿ç»­æ€§å¼‚å¸¸æ—¶å‡ºé”™:", e.message);
                    }
                }
                
                // æ£€æŸ¥å‘¨å›´ç‚¹æ˜¯å¦å½¢æˆç¾¤ä½“
                const startIdx = Math.max(0, index - 3);
                const endIdx = Math.min(values.length, index + 4);
                const nearbyPoints = values.slice(startIdx, endIdx);
                
                const nearbyMean = nearbyPoints.reduce((acc, val) => acc + val, 0) / nearbyPoints.length;
                const globalMean = values.reduce((acc, val) => acc + val, 0) / values.length;
                
                // é¿å…é™¤ä»¥é›¶ï¼ŒåŠ å…¥å®‰å…¨æ£€æŸ¥
                const denominator = Math.max(0.01, Math.abs(globalMean));
                const isCluster = Math.abs((nearbyMean - globalMean) / denominator) > 0.1 && nearbyPoints.length >= 3;
                
                if (isCluster) {
                    return 'ç¾¤ä½“å¼‚å¸¸';
                } else if (isContinuous) {
                    return 'è¿ç»­æ€§å¼‚å¸¸';
                } else {
                    return 'å•ç‚¹å¼‚å¸¸';
                }
            } catch (error) {
                console.error("ç¡®å®šå¼‚å¸¸ç±»å‹æ—¶å‡ºé”™:", error);
                return 'æœªåˆ†ç±»å¼‚å¸¸';  // è¿”å›ä¸€ä¸ªé»˜è®¤å€¼
            }
        }

        // åˆå§‹åŒ–äº‹ä»¶æ§åˆ¶é¢æ¿
        function initEventControls() {
            console.log("åˆå§‹åŒ–äº‹ä»¶æ§åˆ¶é¢æ¿");
            
            // è·å–äº‹ä»¶ç›¸å…³çš„DOMå…ƒç´ 
            eventNameElement = document.getElementById('currentEventName');
            eventDescElement = document.getElementById('currentEventDescription');
            eventProgressContainer = document.getElementById('eventProgressContainer');
            eventProgressBar = document.getElementById('eventProgressBar');
            eventProgressText = document.getElementById('eventProgressText');
            eventDetails = document.getElementById('eventDetails');
            
            // äº‹ä»¶æŒ‰é’®ç‚¹å‡»å¤„ç†
            const eventButtons = document.querySelectorAll('#eventButtons button');
            eventButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const eventType = this.getAttribute('data-event');
                    
                    // å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰æ´»åŠ¨äº‹ä»¶ï¼Œåˆ™å¿½ç•¥
                    if (currentEventSimulation === eventType) return;
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    eventButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    // å¼€å§‹æ¨¡æ‹Ÿæ–°äº‹ä»¶
                    startEventSimulation(eventType);
                });
            });
            
            // åˆå§‹åŒ–æ¸…ç©ºå†å²æŒ‰é’®
            document.getElementById('clearHistoryBtn').addEventListener('click', function() {
                clearDetectionHistory();
            });
            
            // é»˜è®¤è®¾ç½®ä¸ºæ­£å¸¸è¿è¡ŒçŠ¶æ€
            startEventSimulation(bridgeEvents.NORMAL);
        }

        // å¼€å§‹äº‹ä»¶æ¨¡æ‹Ÿ
        function startEventSimulation(eventType) {
            // æ£€æŸ¥äº‹ä»¶ç±»å‹
            if (!eventType) {
                console.warn("æœªæŒ‡å®šäº‹ä»¶ç±»å‹ï¼Œä½¿ç”¨é»˜è®¤å€¼");
                eventType = "NORMAL"; // ä½¿ç”¨é»˜è®¤å€¼
            }
            
            // æ£€æŸ¥äº‹ä»¶è®¾ç½®æ˜¯å¦å­˜åœ¨
            if (typeof eventSettings === 'undefined' || !eventSettings || !eventSettings[eventType]) {
                console.error(`äº‹ä»¶è®¾ç½®æœªå®šä¹‰æˆ–äº‹ä»¶ç±»å‹ ${eventType} ä¸å­˜åœ¨`);
                return;
            }
            
            // åœæ­¢å½“å‰äº‹ä»¶æ¨¡æ‹Ÿ
            if (currentEventSimulation !== null) {
                console.log(`åœæ­¢å½“å‰äº‹ä»¶æ¨¡æ‹Ÿ: ${currentEventSimulation}`);
            }
            
            // è®¾ç½®æ–°çš„äº‹ä»¶æ¨¡æ‹Ÿ
            currentEventSimulation = eventType;
            const eventConfig = eventSettings[eventType];
            
            console.log(`å¼€å§‹æ¨¡æ‹Ÿäº‹ä»¶: ${eventType}, åç§°: ${eventConfig.name}`);
            
            // æ›´æ–°UI - æ·»åŠ éªŒè¯ä»¥é˜²æ­¢å¯¹nullçš„å¼•ç”¨
            if (eventNameElement) eventNameElement.textContent = eventConfig.name;
            if (eventDescElement) eventDescElement.textContent = eventConfig.description;
            
            // æ¸…é™¤ä¸Šä¸€ä¸ªäº‹ä»¶çš„ç±»
            if (eventDetails) {
                eventDetails.className = 'event-details';
                
                // æ·»åŠ å½“å‰äº‹ä»¶çš„ç±»
                if (eventConfig.severity === 'warning') {
                    eventDetails.classList.add('event-warning');
                } else if (eventConfig.severity === 'alert') {
                    eventDetails.classList.add('event-alert');
                }
            }
            
            // è®¾ç½®äº‹ä»¶è¿›åº¦
            if (eventType === bridgeEvents.NORMAL) {
                // æ­£å¸¸çŠ¶æ€æ²¡æœ‰è¿›åº¦æ¡
                eventProgressContainer.style.display = 'none';
                eventProgress = 0;
                eventDuration = 0;
            } else {
                // è®¾ç½®äº‹ä»¶æŒç»­æ—¶é—´ï¼ˆéšæœºåœ¨é…ç½®çš„èŒƒå›´å†…ï¼‰
                eventDuration = Math.floor(Math.random() * 
                    (eventConfig.duration[1] - eventConfig.duration[0] + 1)) + 
                    eventConfig.duration[0];
                
                eventProgress = 0;
                updateEventProgress();
                
                // æ˜¾ç¤ºè¿›åº¦æ¡
                eventProgressContainer.style.display = 'block';
            }
        }

        // æ›´æ–°äº‹ä»¶è¿›åº¦
        function updateEventProgress() {
            if (!currentEventSimulation || currentEventSimulation === bridgeEvents.NORMAL) return;
            
            // å¢åŠ è¿›åº¦
            eventProgress += (100 / eventDuration);
            
            // ç¡®ä¿ä¸è¶…è¿‡100%
            if (eventProgress > 100) {
                eventProgress = 100;
                
                // äº‹ä»¶ç»“æŸï¼Œæ¢å¤æ­£å¸¸çŠ¶æ€
                setTimeout(() => {
                    document.querySelector('#eventButtons button[data-event="normal"]').click();
                }, 1000);
            }
            
            // æ›´æ–°è¿›åº¦æ¡
            eventProgressBar.style.width = `${eventProgress}%`;
            eventProgressText.textContent = `${Math.round(eventProgress)}%`;
        }

        // å°†å¼‚å¸¸æ£€æµ‹ç»“æœæ·»åŠ åˆ°å†å²è®°å½•
        function addToDetectionHistory(result) {
            const historyList = document.getElementById('detectionHistory');
            const noHistoryMsg = historyList.querySelector('.no-history-message');
            
            if (noHistoryMsg) {
                noHistoryMsg.remove();
            }
            
            // åˆ›å»ºå†å²è®°å½•é¡¹
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.dataset.timestamp = new Date().toISOString();
            
            // è·å–å½“å‰äº‹ä»¶åç§°
            const eventName = currentEventSimulation ? 
                eventSettings[currentEventSimulation].name : 'æ­£å¸¸è¿è¡Œ';
                
            // åˆ›å»ºå†å²è®°å½•å†…å®¹
            historyItem.innerHTML = `
                <div class="history-item-header">
                    <div class="history-item-title">æ£€æµ‹ç»“æœ #${document.querySelectorAll('.history-item').length + 1}</div>
                    <div class="history-item-time">${new Date().toLocaleString('zh-CN')}</div>
                </div>
                <div class="history-item-stats">
                    <div>äº‹ä»¶çŠ¶æ€: ${eventName}</div>
                    <div>æ•°æ®ç‚¹: ${result.totalPoints}, å¼‚å¸¸: ${result.anomalyCount}</div>
                    <div>å•ç‚¹å¼‚å¸¸: ${result.singlePointCount}, è¿ç»­æ€§å¼‚å¸¸: ${result.continuousCount}, ç¾¤ä½“å¼‚å¸¸: ${result.clusterCount}</div>
                </div>
            `;
            
            // ç‚¹å‡»å†å²è®°å½•é¡¹æ¢å¤è¯¥æ£€æµ‹ç»“æœ
            historyItem.addEventListener('click', function() {
                restoreDetectionResult(this.dataset.timestamp);
            });
            
            // æ·»åŠ åˆ°å†å²è®°å½•åˆ—è¡¨
            historyList.insertBefore(historyItem, historyList.firstChild);
            
            // å­˜å‚¨å½“å‰æ£€æµ‹ç»“æœ
            saveDetectionResult(historyItem.dataset.timestamp, result);
        }

        // ä¿å­˜æ£€æµ‹ç»“æœ
        function saveDetectionResult(timestamp, result) {
            // è·å–å·²æœ‰çš„å†å²è®°å½•
            let history = JSON.parse(localStorage.getItem('detectionHistory') || '[]');
            
            // æ·»åŠ æ–°è®°å½•
            history.push({
                timestamp: timestamp,
                result: result,
                anomalyChartData: dataChart ? dataChart.data : null,
                event: currentEventSimulation,
                eventName: eventSettings[currentEventSimulation || bridgeEvents.NORMAL].name
            });
            
            // é™åˆ¶æœ€å¤§å†å²è®°å½•æ•°
            if (history.length > 10) {
                history = history.slice(history.length - 10);
            }
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('detectionHistory', JSON.stringify(history));
        }

        // æ¢å¤æ£€æµ‹ç»“æœ
        function restoreDetectionResult(timestamp) {
            // è·å–å†å²è®°å½•
            const history = JSON.parse(localStorage.getItem('detectionHistory') || '[]');
            
            // æŸ¥æ‰¾å¯¹åº”çš„è®°å½•
            const record = history.find(item => item.timestamp === timestamp);
            if (!record) return;
            
            // æ¢å¤æ£€æµ‹ç»“æœæ˜¾ç¤º
            const result = record.result;
            
            // æ›´æ–°ç»Ÿè®¡æ•°å­—
            document.getElementById('totalPoints').textContent = result.totalPoints;
            document.getElementById('anomalyCount').textContent = result.anomalyCount;
            document.getElementById('singlePointCount').textContent = result.singlePointCount;
            document.getElementById('continuousCount').textContent = result.continuousCount;
            document.getElementById('clusterCount').textContent = result.clusterCount;
            
            // æ¢å¤å¼‚å¸¸åˆ—è¡¨
            document.getElementById('anomalyList').innerHTML = '';
            
            // æ˜¾ç¤ºåˆ†æç»“æœ
            analysisSummary.style.display = 'block';
            analysisLoader.style.display = 'none';
            noAnalysisMessage.style.display = 'none';
            
            // å¦‚æœæœ‰å›¾è¡¨æ•°æ®ï¼Œæ¢å¤å›¾è¡¨
            if (record.anomalyChartData) {
                restoreAnomalyChart(record.anomalyChartData);
            }
            
            // æ˜¾ç¤ºæ¢å¤æç¤º
            alert(`å·²æ¢å¤ ${new Date(timestamp).toLocaleString('zh-CN')} çš„æ£€æµ‹ç»“æœï¼Œåœ¨"${record.eventName}"çŠ¶æ€ä¸‹è¿›è¡Œçš„æ£€æµ‹`);
        }

        // æ¢å¤å¼‚å¸¸æ£€æµ‹å›¾è¡¨
        function restoreAnomalyChart(chartData) {
            if (!chartData) return;
            
            const ctx = document.getElementById('anomalyChart').getContext('2d');
            
            // é”€æ¯ç°æœ‰å›¾è¡¨
            if (anomalyChart) {
                anomalyChart.destroy();
            }
            
            // åˆ›å»ºæ–°å›¾è¡¨
            anomalyChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true
                            }
                        },
                        annotation: {
                            annotations: {
                                anomalyThreshold: {
                                    type: 'line',
                                    yMin: 2,
                                    yMax: 2,
                                    borderColor: 'rgba(255, 0, 0, 0.5)',
                                    borderWidth: 2,
                                    borderDash: [6, 6],
                                    label: {
                                        display: true,
                                        content: 'å¼‚å¸¸é˜ˆå€¼ (Z-score = 2)',
                                        position: 'start'
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'æ•°æ®ç‚¹'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Z-Score'
                            }
                        }
                    }
                }
            });
        }

        // æ¸…ç©ºæ£€æµ‹å†å²
        function clearDetectionHistory() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                // æ¸…ç©ºlocalStorage
                localStorage.removeItem('detectionHistory');
                
                // æ¸…ç©ºå†å²åˆ—è¡¨
                const historyList = document.getElementById('detectionHistory');
                historyList.innerHTML = '<div class="no-history-message">æš‚æ— å†å²è®°å½•</div>';
            }
        }

        // åŠ è½½å†å²è®°å½•
        function loadDetectionHistory() {
            const history = JSON.parse(localStorage.getItem('detectionHistory') || '[]');
            const historyList = document.getElementById('detectionHistory');
            
            if (history.length === 0) {
                historyList.innerHTML = '<div class="no-history-message">æš‚æ— å†å²è®°å½•</div>';
                return;
            }
            
            // æ¸…ç©ºç°æœ‰åˆ—è¡¨
            historyList.innerHTML = '';
            
            // æ·»åŠ å†å²è®°å½•
            history.forEach((record, index) => {
                const result = record.result;
                
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.dataset.timestamp = record.timestamp;
                
                historyItem.innerHTML = `
                    <div class="history-item-header">
                        <div class="history-item-title">æ£€æµ‹ç»“æœ #${history.length - index}</div>
                        <div class="history-item-time">${new Date(record.timestamp).toLocaleString('zh-CN')}</div>
                    </div>
                    <div class="history-item-stats">
                        <div>äº‹ä»¶çŠ¶æ€: ${record.eventName || 'æ­£å¸¸è¿è¡Œ'}</div>
                        <div>æ•°æ®ç‚¹: ${result.totalPoints}, å¼‚å¸¸: ${result.anomalyCount}</div>
                        <div>å•ç‚¹å¼‚å¸¸: ${result.singlePointCount}, è¿ç»­æ€§å¼‚å¸¸: ${result.continuousCount}, ç¾¤ä½“å¼‚å¸¸: ${result.clusterCount}</div>
                    </div>
                `;
                
                // ç‚¹å‡»å†å²è®°å½•é¡¹æ¢å¤è¯¥æ£€æµ‹ç»“æœ
                historyItem.addEventListener('click', function() {
                    restoreDetectionResult(this.dataset.timestamp);
                });
                
                historyList.appendChild(historyItem);
            });
        }

        // äº‹ä»¶é¢„æµ‹æ•°æ®ç»“æ„
        eventPredictions = [
            {
                id: 1,
                eventType: 'ç»“æ„åº”å˜å¼‚å¸¸',
                probability: 0.85,
                reasoning: 'åŒ—æ®µåº”å˜ä¼ æ„Ÿå™¨è¿ç»­3å°æ—¶æ•°æ®åé«˜ï¼Œè¶…è¿‡æ­£å¸¸èŒƒå›´20%',
                timestamp: '2023-11-18 08:45',
                severity: 'high',
                relatedSensors: ['åº”å˜ä¼ æ„Ÿå™¨-ä¸»æ¡¥åŒ—æ®µ', 'åº”å˜ä¼ æ„Ÿå™¨-ä¸»æ¡¥ä¸­æ®µ']
            },
            {
                id: 2,
                eventType: 'äº¤é€šè´Ÿè½½è¿‡é«˜',
                probability: 0.68,
                reasoning: 'ä¸­æ®µæŒ¯åŠ¨ä¼ æ„Ÿå™¨æ•°æ®æ³¢åŠ¨é¢‘ç¹ï¼Œä¸å†å²äº¤é€šé«˜å³°æœŸæ¨¡å¼åŒ¹é…',
                timestamp: '2023-11-18 17:30',
                severity: 'medium',
                relatedSensors: ['æŒ¯åŠ¨ä¼ æ„Ÿå™¨-ä¸»æ¡¥ä¸­æ®µ', 'æŒ¯åŠ¨ä¼ æ„Ÿå™¨-ä¸»æ¡¥å—æ®µ']
            },
            {
                id: 3,
                eventType: 'æ¸©åº¦å¼‚å¸¸æ³¢åŠ¨',
                probability: 0.52,
                reasoning: 'å—æ®µæ¸©åº¦ä¼ æ„Ÿå™¨è¿‘æœŸæ•°æ®æ³¢åŠ¨è¶…å‡ºå­£èŠ‚æ­£å¸¸èŒƒå›´',
                timestamp: '2023-11-18 14:15',
                severity: 'low',
                relatedSensors: ['æ¸©åº¦ä¼ æ„Ÿå™¨-ä¸»æ¡¥å—æ®µ']
            }
        ];

        // æ‘„åƒå¤´æ•°æ®
        function generateCameras() {
            const cameras = [];
            const sections = ['åŒ—æ®µ', 'ä¸­æ®µ', 'å—æ®µ', 'ä¸œæ®µ', 'è¥¿æ®µ'];
            const positions = ['æ¡¥é¢', 'æ¡¥å¢©', 'æ¡¥å¡”', 'åŠç´¢', 'æ”¯åº§'];
            
            // ç”Ÿæˆ50ä¸ªæ‘„åƒå¤´æ•°æ®
            for (let i = 1; i <= 50; i++) {
                const section = sections[Math.floor(Math.random() * sections.length)];
                const position = positions[Math.floor(Math.random() * positions.length)];
                const statusChance = Math.random();
                let status;
                
                if (statusChance > 0.85) {
                    status = 'offline';
                } else if (statusChance > 0.7) {
                    status = 'warning';
                } else {
                    status = 'online';
                }
                
                cameras.push({
                    id: `CAM-${i.toString().padStart(3, '0')}`,
                    name: `${section}${position}æ‘„åƒå¤´-${i}`,
                    status: status,
                    sensorId: `ä¼ æ„Ÿå™¨-${section}-${position}-${i.toString().padStart(2, '0')}`,
                    section: section,
                    position: position,
                    lastUpdate: new Date(Date.now() - Math.floor(Math.random() * 3600000)).toLocaleString('zh-CN')
                });
            }
            
            return cameras;
        }

        // æ˜¾ç¤ºäº‹ä»¶é¢„æµ‹
        function displayEventPredictions() {
            const container = document.getElementById('event-prediction-container');
            if (!container) return;
            
            // æ¸…ç©ºå®¹å™¨
            container.innerHTML = '';
            
            if (eventPredictions.length === 0) {
                container.innerHTML = '<div class="no-predictions">æš‚æ— å¼‚å¸¸äº‹ä»¶é¢„æµ‹</div>';
                return;
            }
            
            // æŒ‰æ¦‚ç‡é™åºæ’åº
            eventPredictions.sort((a, b) => b.probability - a.probability);
            
            // ä¸ºæ¯ä¸ªäº‹ä»¶åˆ›å»ºä¸€ä¸ªé¢„æµ‹å¡ç‰‡
            eventPredictions.forEach(event => {
                let severityClass = '';
                switch (event.severity) {
                    case 'high':
                        severityClass = 'severity-high';
                        break;
                    case 'medium':
                        severityClass = 'severity-medium';
                        break;
                    default:
                        severityClass = 'severity-low';
                }
                
                const probability = (event.probability * 100).toFixed(1);
                
                // åˆ›å»ºé¢„æµ‹å¡ç‰‡
                const card = document.createElement('div');
                card.className = `event-prediction-card ${severityClass}`;
                card.innerHTML = `
                    <div class="event-header">
                        <div class="event-type">${event.eventType}</div>
                        <div class="event-probability">${probability}%</div>
                    </div>
                    <div class="event-reasoning">${event.reasoning}</div>
                    <div class="event-details">
                        <span class="event-timestamp">æ£€æµ‹æ—¶é—´: ${event.timestamp}</span>
                        <span class="event-sensors">å…³è”ä¼ æ„Ÿå™¨: ${event.relatedSensors.join(', ')}</span>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }

        // æ˜¾ç¤ºæ‘„åƒå¤´
        function displayCameras(cameras) {
            const cameraGrid = document.getElementById('cameraGrid');
            cameraGrid.innerHTML = '';
            
            if (!cameras || cameras.length === 0) {
                cameraGrid.innerHTML = '<div class="no-cameras-message">æœªæ‰¾åˆ°åŒ¹é…çš„æ‘„åƒå¤´</div>';
                return;
            }
            
            cameras.forEach(camera => {
                const cameraItem = document.createElement('div');
                cameraItem.className = 'camera-item';
                cameraItem.dataset.id = camera.id;
                cameraItem.dataset.section = camera.section;
                cameraItem.dataset.status = camera.status;
                
                let statusClass, statusText;
                switch (camera.status) {
                    case 'offline':
                        statusClass = 'camera-offline';
                        statusText = 'ç¦»çº¿';
                        break;
                    case 'warning':
                        statusClass = 'camera-warning';
                        statusText = 'è­¦å‘Š';
                        break;
                    default:
                        statusClass = 'camera-online';
                        statusText = 'åœ¨çº¿';
                }
                
                // å¢åŠ æ‘„åƒå¤´è§†å›¾ - ç©ºç™½æ¡†
                cameraItem.innerHTML = `
                    <div class="camera-header">
                        <div class="camera-name">${camera.name}</div>
                        <div class="camera-status ${statusClass}">${statusText}</div>
                    </div>
                    <div class="camera-view">
                        <!-- æ‘„åƒå¤´è§†å›¾åŒºåŸŸ -->
                        <div class="camera-placeholder">
                            <div class="camera-no-signal ${camera.status === 'offline' ? 'visible' : ''}">æ— ä¿¡å·</div>
                        </div>
                    </div>
                    <div class="camera-footer">
                        <div class="camera-id">${camera.id}</div>
                        <div class="camera-update">æ›´æ–°: ${camera.lastUpdate}</div>
                    </div>
                `;
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œæ˜¾ç¤ºè¯¦æƒ…
                cameraItem.addEventListener('click', function() {
                    showCameraDetails(camera);
                });
                
                cameraGrid.appendChild(cameraItem);
            });
        }

        // æ˜¾ç¤ºæ‘„åƒå¤´è¯¦æƒ…
        function showCameraDetails(camera) {
            const modal = document.getElementById('cameraDetailModal') || createCameraDetailModal();
            const modalTitle = modal.querySelector('.modal-title');
            const modalBody = modal.querySelector('.modal-body');
            
            modalTitle.textContent = `${camera.name} (${camera.id})`;
            
            let statusClass, statusText;
            switch (camera.status) {
                case 'offline':
                    statusClass = 'badge-danger';
                    statusText = 'ç¦»çº¿';
                    break;
                case 'warning':
                    statusClass = 'badge-warning';
                    statusText = 'è­¦å‘Š';
                    break;
                default:
                    statusClass = 'badge-success';
                    statusText = 'åœ¨çº¿';
            }
            
            modalBody.innerHTML = `
                <div class="camera-detail-view">
                    <div class="camera-placeholder large">
                        <div class="camera-no-signal ${camera.status === 'offline' ? 'visible' : ''}">æ— ä¿¡å·</div>
                    </div>
                </div>
                <div class="camera-detail-info">
                    <p><strong>ID:</strong> ${camera.id}</p>
                    <p><strong>ä½ç½®:</strong> ${camera.section} - ${camera.position}</p>
                    <p><strong>çŠ¶æ€:</strong> <span class="badge ${statusClass}">${statusText}</span></p>
                    <p><strong>å…³è”ä¼ æ„Ÿå™¨:</strong> ${camera.sensorId}</p>
                    <p><strong>æœ€åæ›´æ–°:</strong> ${camera.lastUpdate}</p>
                </div>
                <div class="camera-controls">
                    <button class="btn btn-primary" disabled>æ”¾å¤§</button>
                    <button class="btn btn-primary" disabled>æ—‹è½¬</button>
                    <button class="btn btn-primary" disabled>æˆªå›¾</button>
                    <button class="btn btn-primary" disabled>ä¸‹è½½å½•åƒ</button>
                </div>
            `;
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            $(modal).modal('show');
        }

        // åˆ›å»ºæ‘„åƒå¤´è¯¦æƒ…æ¨¡æ€æ¡†
        function createCameraDetailModal() {
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.id = 'cameraDetailModal';
            modal.tabIndex = '-1';
            modal.role = 'dialog';
            modal.setAttribute('aria-labelledby', 'cameraDetailModalLabel');
            modal.setAttribute('aria-hidden', 'true');
            
            modal.innerHTML = `
                <div class="modal-dialog modal-lg" role="document">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="cameraDetailModalLabel">æ‘„åƒå¤´è¯¦æƒ…</h5>
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                                <span aria-hidden="true">&times;</span>
                            </button>
                        </div>
                        <div class="modal-body">
                            <!-- å†…å®¹å°†åŠ¨æ€å¡«å…… -->
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-dismiss="modal">å…³é—­</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            return modal;
        }

        // æ·»åŠ æ‘„åƒå¤´ç›¸å…³çš„CSSæ ·å¼
        function addCameraStyles() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .camera-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                    grid-gap: 20px;
                    margin-top: 20px;
                }
                
                .camera-card {
                    position: relative;
                    border-radius: 6px;
                    overflow: hidden;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    transition: transform 0.2s, box-shadow 0.2s;
                    background-color: #fff;
                }
                
                .camera-card:hover {
                    transform: translateY(-5px);
                    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
                }
                
                .camera-feed {
                    height: 180px;
                    position: relative;
                    overflow: hidden;
                    background-color: #eee;
                }
                
                .camera-feed img, .camera-feed canvas {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                }
                
                .camera-status {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: bold;
                    background-color: rgba(0,0,0,0.5);
                    color: white;
                }
                
                .camera-status.online {
                    background-color: rgba(40, 167, 69, 0.8);
                }
                
                .camera-status.offline {
                    background-color: rgba(108, 117, 125, 0.8);
                }
                
                .camera-status.warning {
                    background-color: rgba(255, 193, 7, 0.8);
                }
                
                .camera-info {
                    padding: 12px;
                }
                
                .camera-name {
                    font-weight: bold;
                    margin-bottom: 5px;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
                
                .camera-location {
                    color: #666;
                    font-size: 12px;
                    margin-bottom: 8px;
                }
                
                .camera-metrics {
                    display: flex;
                    justify-content: space-between;
                    font-size: 12px;
                    color: #666;
                }
                
                .camera-timestamp {
                    color: #888;
                    font-style: italic;
                }
                
                .camera-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0;
                    transition: opacity 0.3s;
                }
                
                .camera-feed:hover .camera-overlay {
                    opacity: 1;
                }
                
                .camera-actions {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                }
                
                .camera-action-btn {
                    background-color: rgba(255,255,255,0.2);
                    color: white;
                    border: none;
                    border-radius: 50%;
                    width: 40px;
                    height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 5px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                }
                
                .camera-action-btn:hover {
                    background-color: rgba(255,255,255,0.4);
                }
                
                .no-data-message {
                    text-align: center;
                    padding: 40px;
                    background-color: #f8f9fa;
                    border-radius: 6px;
                    color: #6c757d;
                    margin-top: 20px;
                }
                
                .offline-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                }
                
                .no-camera-results {
                    text-align: center;
                    padding: 20px;
                    color: #6c757d;
                    display: none;
                }
                
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(styleElement);
        }

        // æ·»åŠ æ‘„åƒå¤´æ ·å¼
        addCameraStyles();

        // åˆå§‹åŒ–äº‹ä»¶é¢„æµ‹
        function initializeEventPredictions() {
            // éšæœºç”Ÿæˆä¸€äº›åˆå§‹äº‹ä»¶é¢„æµ‹
            eventPredictions = [];
            
            // å¦‚æœæœ‰å¼‚å¸¸æ•°æ®ï¼Œç”Ÿæˆç›¸åº”çš„äº‹ä»¶é¢„æµ‹
            const abnormalData = sensorData.filter(item => item.status !== 'normal');
            
            if (abnormalData.length > 0) {
                // æŒ‰ä¼ æ„Ÿå™¨ç±»å‹åˆ†ç»„å¼‚å¸¸æ•°æ®
                const groupedByType = {};
                abnormalData.forEach(item => {
                    if (!groupedByType[item.sensorType]) {
                        groupedByType[item.sensorType] = [];
                    }
                    groupedByType[item.sensorType].push(item);
                });
                
                // ä¸ºä¸»è¦çš„å¼‚å¸¸ç±»å‹åˆ›å»ºäº‹ä»¶é¢„æµ‹
                Object.keys(groupedByType).forEach(type => {
                    const count = groupedByType[type].length;
                    if (count > 5) { // è‡³å°‘æœ‰5ä¸ªå¼‚å¸¸ç‚¹æ‰åˆ›å»ºé¢„æµ‹
                        const locations = [...new Set(groupedByType[type].map(item => item.location))];
                        const sensorIds = [...new Set(groupedByType[type].map(item => item.sensorId))].slice(0, 3);
                        let eventType, reasoning, severity;
                        
                        switch(type) {
                            case 'æ¸©åº¦':
                                eventType = 'æ¸©åº¦å¼‚å¸¸æ³¢åŠ¨';
                                reasoning = `${locations.join('ã€')}æ¸©åº¦ä¼ æ„Ÿå™¨æ•°æ®å‡ºç°éæ­£å¸¸æ³¢åŠ¨ï¼Œå¯èƒ½å—ç¯å¢ƒå› ç´ å½±å“`;
                                severity = 'medium';
                                break;
                            case 'åº”å˜':
                                eventType = 'ç»“æ„åº”å˜å¼‚å¸¸';
                                reasoning = `${locations.join('ã€')}åº”å˜ä¼ æ„Ÿå™¨æ•°æ®æŒç»­åé«˜ï¼Œç»“æ„æ‰¿å—å‹åŠ›å¼‚å¸¸`;
                                severity = 'high';
                                break;
                            case 'æŒ¯åŠ¨':
                                eventType = 'å¼‚å¸¸æŒ¯åŠ¨';
                                reasoning = `${locations.join('ã€')}æŒ¯åŠ¨ä¼ æ„Ÿå™¨æ£€æµ‹åˆ°è¶…å‡ºæ­£å¸¸èŒƒå›´çš„æŒ¯åŠ¨`;
                                severity = 'medium';
                                break;
                            case 'å€¾è§’':
                                eventType = 'ç»“æ„å€¾æ–œ';
                                reasoning = `${locations.join('ã€')}å€¾è§’ä¼ æ„Ÿå™¨æ•°æ®æ˜¾ç¤ºç»“æ„è§’åº¦å¼‚å¸¸`;
                                severity = 'high';
                                break;
                            case 'ä½ç§»':
                                eventType = 'ç»“æ„ä½ç§»å¼‚å¸¸';
                                reasoning = `${locations.join('ã€')}ä½ç§»ä¼ æ„Ÿå™¨æ˜¾ç¤ºæ¡¥æ¢éƒ¨ä»¶å‡ºç°å¼‚å¸¸ç§»åŠ¨`;
                                severity = 'high';
                                break;
                            case 'è½½é‡':
                                eventType = 'è´Ÿè½½è¿‡é«˜';
                                reasoning = `${locations.join('ã€')}è½½é‡ä¼ æ„Ÿå™¨æ˜¾ç¤ºæ¡¥æ¢æ‰¿å—å‹åŠ›è¶…å‡ºå®‰å…¨èŒƒå›´`;
                                severity = 'medium';
                                break;
                            default:
                                eventType = `${type}æ•°æ®å¼‚å¸¸`;
                                reasoning = `${locations.join('ã€')}${type}ä¼ æ„Ÿå™¨æ•°æ®å‡ºç°å¼‚å¸¸æ³¢åŠ¨`;
                                severity = 'low';
                        }
                        
                        eventPredictions.push({
                            id: Date.now() + Math.random(),
                            eventType: eventType,
                            probability: 0.5 + Math.random() * 0.4,
                            reasoning: reasoning,
                            timestamp: new Date().toLocaleString('zh-CN'),
                            severity: severity,
                            relatedSensors: sensorIds
                        });
                    }
                });
            }
            
            // å¦‚æœæ²¡æœ‰åŸºäºæ•°æ®ç”Ÿæˆçš„é¢„æµ‹ï¼Œåˆ™ç”Ÿæˆä¸€ä¸ª"æ­£å¸¸è¿è¡Œ"çš„é¢„æµ‹
            if (eventPredictions.length === 0) {
                eventPredictions.push({
                    id: Date.now(),
                    eventType: 'æ­£å¸¸è¿ç»´ä¸­',
                    probability: 0.95,
                    reasoning: 'æ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®åœ¨æ­£å¸¸èŒƒå›´å†…ï¼Œæ— å¼‚å¸¸æ¨¡å¼',
                    timestamp: new Date().toLocaleString('zh-CN'),
                    severity: 'low',
                    relatedSensors: ['ç³»ç»ŸçŠ¶æ€']
                });
            }
            
            // æ˜¾ç¤ºäº‹ä»¶é¢„æµ‹
            displayEventPredictions();
        }

        // æœç´¢å’Œç­›é€‰æ‘„åƒå¤´
        function searchAndFilterCameras() {
            const searchTerm = document.getElementById('camera-search').value.toLowerCase();
            const statusFilter = document.getElementById('camera-filter').value;
            const sectionFilter = document.getElementById('section-filter').value;
            
            const filteredCameras = allCameras.filter(camera => {
                // æœç´¢æ¡ä»¶
                const matchesSearch = 
                    camera.name.toLowerCase().includes(searchTerm) ||
                    camera.id.toLowerCase().includes(searchTerm) ||
                    camera.sensorId.toLowerCase().includes(searchTerm);
                
                // çŠ¶æ€ç­›é€‰
                const matchesStatus = 
                    statusFilter === 'all' || 
                    (statusFilter === 'online' && camera.status === 'online') ||
                    (statusFilter === 'offline' && camera.status === 'offline') ||
                    (statusFilter === 'warning' && camera.status === 'warning');
                
                // åŒºæ®µç­›é€‰
                const matchesSection = 
                    sectionFilter === 'all' ||
                    (sectionFilter === 'north' && camera.section === 'åŒ—æ®µ') ||
                    (sectionFilter === 'center' && camera.section === 'ä¸­æ®µ') ||
                    (sectionFilter === 'south' && camera.section === 'å—æ®µ') ||
                    (sectionFilter === 'east' && camera.section === 'ä¸œæ®µ') ||
                    (sectionFilter === 'west' && camera.section === 'è¥¿æ®µ');
                
                return matchesSearch && matchesStatus && matchesSection;
            });
            
            displayCameras(filteredCameras);
        }

        // æ¨¡æ‹Ÿæ‰“å¼€æ‘„åƒå¤´ç›´æ’­
        function openCameraFeed(cameraId) {
            const camera = allCameras.find(cam => cam.id === cameraId);
            if (!camera) return;
            
            if (camera.status === 'offline') {
                alert(`æ— æ³•è¿æ¥æ‘„åƒå¤´ ${camera.id}ï¼šè®¾å¤‡ç¦»çº¿`);
                return;
            }
            
            alert(`æ­£åœ¨è¿æ¥åˆ°æ‘„åƒå¤´ï¼š${camera.name}\nä¼ æ„Ÿå™¨IDï¼š${camera.sensorId}`);
            // è¿™é‡Œå¯ä»¥å®ç°å®é™…çš„æ‘„åƒå¤´è¿æ¥é€»è¾‘
        }

        // éšæœºæ›´æ–°ä¼ æ„Ÿå™¨æ•°æ®
        function randomlyUpdateData() {
            if (!sensorData || sensorData.length === 0) return;
            
            // è·å–å½“å‰æ—¶é—´ä½œä¸ºæ–°çš„æ•°æ®ç‚¹æ—¶é—´æˆ³
            const now = new Date();
            const timeStr = now.toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // è·å–å”¯ä¸€çš„ä¼ æ„Ÿå™¨IDåˆ—è¡¨
            const uniqueSensors = [...new Set(sensorData.map(item => item.sensorId))];
            
            // åˆ›å»ºç¯å¢ƒå› ç´ ï¼Œç¡®ä¿æ•°æ®ä¹‹é—´çš„å…³è”æ€§
            const environmentalFactor = Math.sin(Date.now() / 10000000) * 0.15; // ç¼“æ…¢å˜åŒ–çš„ç¯å¢ƒå› ç´ 
            const timeOfDayFactor = Math.sin(now.getHours() / 24 * Math.PI) * 0.1; // æ—¥é—´å˜åŒ–å› ç´ 
            const bridgeLoadFactor = Math.sin(Date.now() / 3600000) * 0.08; // æ¡¥æ¢è´Ÿè½½å˜åŒ–
            
            // å…¨å±€æ¸©åº¦å½±å“
            const temperature = 20 + Math.sin(now.getHours() / 24 * Math.PI * 2) * 5 + Math.random() * 2;
            
            // ä¸ºæ¯ä¸ªä¼ æ„Ÿå™¨åˆ›å»ºæ–°çš„æ•°æ®ç‚¹
            uniqueSensors.forEach(sensorId => {
                // è·å–è¯¥ä¼ æ„Ÿå™¨çš„å†å²æ•°æ®
                const sensorPoints = sensorData.filter(item => item.sensorId === sensorId);
                const currentValue = sensorPoints[sensorPoints.length - 1].value;
                
                // æ ¹æ®ä¼ æ„Ÿå™¨IDåˆ†æä¼ æ„Ÿå™¨ç±»å‹å’ŒåŒºæ®µ
                let sensorType = 'å…¶ä»–';
                let sensorLocation = 'ä¸­æ®µ';
                
                if (sensorId.includes('æ¸©åº¦')) sensorType = 'æ¸©åº¦';
                else if (sensorId.includes('åº”å˜')) sensorType = 'åº”å˜';
                else if (sensorId.includes('æŒ¯åŠ¨')) sensorType = 'æŒ¯åŠ¨';
                else if (sensorId.includes('å€¾è§’')) sensorType = 'å€¾è§’';
                
                for (const section of ['åŒ—æ®µ', 'ä¸­æ®µ', 'å—æ®µ', 'ä¸œæ®µ', 'è¥¿æ®µ']) {
                    if (sensorId.includes(section)) {
                        sensorLocation = section;
                        break;
                    }
                }
                
                // è®¡ç®—åŒºæ®µé—´çš„"è·ç¦»"ä»¥ç¡®ä¿ç›¸é‚»åŒºæ®µçš„æ•°æ®è¶‹åŠ¿ç›¸ä¼¼
                function getSectionDistance(section1, section2) {
                    const sections = ['åŒ—æ®µ', 'ä¸­æ®µ', 'å—æ®µ', 'ä¸œæ®µ', 'è¥¿æ®µ'];
                    const idx1 = sections.indexOf(section1);
                    const idx2 = sections.indexOf(section2);
                    return Math.abs(idx1 - idx2);
                }
                
                // æ ¹æ®ä¼ æ„Ÿå™¨ç±»å‹è·å–æ•°æ®èŒƒå›´
                const range = sensorRanges[sensorType] || sensorRanges['å…¶ä»–'];
                
                // è®¡ç®—åŸºç¡€å˜åŒ–é‡
                let baseChange = 0;
                let multiplier = 1.0;
                
                // åŸºç¡€éšæœºæ³¢åŠ¨ (å°å¹…)
                const randomFactor = (Math.random() * 2 - 1) * 0.01 * currentValue;
                
                // ç¯å¢ƒå› ç´ å½±å“
                let environmentalImpact = 0;
                if (sensorType === 'æ¸©åº¦') {
                    environmentalImpact = environmentalFactor * 1.2 + (temperature - 20) * 0.1;
                } else if (sensorType === 'åº”å˜') {
                    environmentalImpact = bridgeLoadFactor * 1.5 + timeOfDayFactor * 0.5;
                } else if (sensorType === 'æŒ¯åŠ¨') {
                    environmentalImpact = bridgeLoadFactor * 1.2 + environmentalFactor * 0.8;
                } else if (sensorType === 'å€¾è§’') {
                    environmentalImpact = bridgeLoadFactor * 0.9 + environmentalFactor * 1.1;
                } else {
                    environmentalImpact = environmentalFactor * 0.8 + timeOfDayFactor * 0.7;
                }
                
                // æ€»å˜åŒ–é‡ = ç¯å¢ƒå½±å“ + éšæœºå™ªå£°
                baseChange = (environmentalImpact * currentValue * 0.05) + randomFactor;
                
                // åº”ç”¨å½±å“å› å­
                baseChange *= multiplier;
                
                // è®¡ç®—æ–°å€¼
                let newValue = currentValue + baseChange;
                
                // ç¡®ä¿æ–°å€¼åœ¨åˆç†èŒƒå›´å†…
                const minValue = range.normal[0] * 0.9;
                const maxValue = range.normal[1] * 1.1;
                
                if (newValue < minValue) newValue = minValue + Math.random() * (range.normal[0] - minValue);
                if (newValue > maxValue) newValue = maxValue - Math.random() * (maxValue - range.normal[1]);
                
                // ç¡®ä¿æ•°æ®çš„è¿ç»­æ€§
                const maxChange = currentValue * 0.15; // æœ€å¤§å…è®¸15%çš„å˜åŒ–
                if (Math.abs(newValue - currentValue) > maxChange) {
                    newValue = currentValue + (Math.sign(newValue - currentValue) * maxChange * Math.random());
                }
                
                // ç¡®å®šä¼ æ„Ÿå™¨çŠ¶æ€
                let status = 'normal';
                if (newValue > range.warning[1] || newValue < range.warning[0]) {
                    status = 'warning';
                }
                if (newValue > range.danger[1] || newValue < range.danger[0]) {
                    status = 'danger';
                }
                
                // åˆ›å»ºæ–°çš„æ•°æ®ç‚¹
                const newDataPoint = {
                    timestamp: timeStr,
                    sensorId: sensorId,
                    value: newValue,
                    status: status
                };
                
                // æ·»åŠ åˆ°æ•°æ®é›†
                sensorData.push(newDataPoint);
                
                // æ›´æ–°UI
                addDataToTable(newDataPoint);
                
                // æ›´æ–°å›¾è¡¨
                updateCharts();
                
                // æ›´æ–°ç›¸å…³æ‘„åƒå¤´çŠ¶æ€
                updateCameraStatus(sensorId, status);
            });
            
            // äº‹ä»¶é¢„æµ‹æ¦‚ç‡æ›´æ–°
            updateEventPredictions();
            
            // é™åˆ¶æ•°æ®ç‚¹æ•°é‡ï¼Œä¿ç•™æœ€è¿‘çš„2000ä¸ªæ•°æ®ç‚¹
            if (sensorData.length > 2000) {
                sensorData = sensorData.slice(sensorData.length - 2000);
                refreshTable();
            }
        }

        // æ›´æ–°äº‹ä»¶é¢„æµ‹æ¦‚ç‡
        function updateEventPredictions() {
            // æ ¹æ®ä¼ æ„Ÿå™¨æ•°æ®æ›´æ–°äº‹ä»¶é¢„æµ‹æ¦‚ç‡
            eventPredictions.forEach(prediction => {
                // æ£€æŸ¥ç›¸å…³ä¼ æ„Ÿå™¨çš„æœ€æ–°çŠ¶æ€
                const relevantSensors = prediction.relatedSensors;
                let abnormalCount = 0;
                
                relevantSensors.forEach(sensorId => {
                    const sensorData = findLastSensorData(sensorId);
                    if (sensorData && (sensorData.status === 'warning' || sensorData.status === 'danger')) {
                        abnormalCount++;
                    }
                });
                
                // æ›´æ–°æ¦‚ç‡ï¼ˆå¼‚å¸¸ä¼ æ„Ÿå™¨è¶Šå¤šï¼Œæ¦‚ç‡è¶Šé«˜ï¼‰
                const ratio = abnormalCount / relevantSensors.length;
                // å¢åŠ ä¸€äº›éšæœºæ³¢åŠ¨ä½¿é¢„æµ‹æ˜¾å¾—æ›´è‡ªç„¶
                const randomFactor = Math.random() * 0.1 - 0.05;
                
                prediction.probability = Math.max(0.1, Math.min(0.95, prediction.probability * 0.6 + ratio * 0.4 + randomFactor));
                
                // æ›´æ–°æ—¶é—´æˆ³
                prediction.timestamp = new Date().toLocaleString('zh-CN');
                
                // æ›´æ–°ä¸¥é‡ç¨‹åº¦
                if (prediction.probability > 0.75) {
                    prediction.severity = 'high';
                } else if (prediction.probability > 0.5) {
                    prediction.severity = 'medium';
                } else {
                    prediction.severity = 'low';
                }
            });
            
            // åˆ·æ–°é¢„æµ‹æ˜¾ç¤º
            displayEventPredictions();
        }

        // æŸ¥æ‰¾ä¼ æ„Ÿå™¨æœ€æ–°æ•°æ®
        function findLastSensorData(sensorId) {
            const sensorPoints = sensorData.filter(item => item.sensorId === sensorId);
            if (sensorPoints.length > 0) {
                return sensorPoints[sensorPoints.length - 1];
            }
            return null;
        }

        // æ›´æ–°æ‘„åƒå¤´çŠ¶æ€
        function updateCameraStatus(sensorId, sensorStatus) {
            // æŸ¥æ‰¾ä¸è¯¥ä¼ æ„Ÿå™¨å…³è”çš„æ‰€æœ‰æ‘„åƒå¤´
            const relatedCameras = allCameras.filter(cam => cam.sensorId === sensorId);
            
            if (relatedCameras.length === 0) return;
            
            // æ ¹æ®ä¼ æ„Ÿå™¨çŠ¶æ€æ›´æ–°æ‘„åƒå¤´çŠ¶æ€
            relatedCameras.forEach(camera => {
                // åªæœ‰å½“æ‘„åƒå¤´ä¸æ˜¯ç¦»çº¿çŠ¶æ€æ—¶æ‰è¿›è¡Œæ›´æ–°
                if (camera.status !== 'offline') {
                    if (sensorStatus === 'danger') {
                        camera.status = 'warning'; // ä¼ æ„Ÿå™¨å‘Šè­¦æ—¶ï¼Œæ‘„åƒå¤´çŠ¶æ€è®¾ä¸ºè­¦å‘Š
                    } else {
                        // 80%çš„æ¦‚ç‡ä¿æŒåŸçŠ¶æ€ï¼Œ20%çš„æ¦‚ç‡æ›´æ–°ä¸ºä¼ æ„Ÿå™¨çŠ¶æ€
                        if (Math.random() > 0.8) {
                            camera.status = sensorStatus === 'warning' ? 'warning' : 'online';
                        }
                    }
                    camera.lastUpdate = new Date().toLocaleString('zh-CN');
                }
            });
            
            // æ›´æ–°æ‘„åƒå¤´æ˜¾ç¤º
            displayCameras();
        }

        // æ–‡æ¡£åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log("é¡µé¢å·²åŠ è½½ï¼Œå¼€å§‹åˆå§‹åŒ–...");
            
            // æ£€æŸ¥ç™»å½•çŠ¶æ€
            checkLoginStatus();
            
            // åˆå§‹åŒ–å…¶ä»–åŠŸèƒ½...
            
            // ç»‘å®šç™»å½•æŒ‰é’®äº‹ä»¶
            if (loginButton) {
                loginButton.addEventListener('click', handleLogin);
            } else {
                console.warn("æ‰¾ä¸åˆ°ç™»å½•æŒ‰é’®ï¼Œè¯·æ£€æŸ¥HTMLç»“æ„");
            }
            
            // ç»‘å®šç™»å‡ºæŒ‰é’®äº‹ä»¶
            if (logoutButton) {
                logoutButton.addEventListener('click', handleLogout);
            }
            
            // å¦‚æœæ‰¾åˆ°ç™»å½•è¡¨å•ï¼Œç»‘å®šå›è½¦é”®ç™»å½•åŠŸèƒ½
            if (passwordInput) {
                passwordInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        handleLogin();
                    }
                });
            }
            
            // ... å…¶ä»–åˆå§‹åŒ–ä»£ç  ...
        });

        // åœ¨é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–äº‹ä»¶é¢„æµ‹åŒºåŸŸ
        function initEventPredictionArea() {
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) return;
            
            // åˆ›å»ºäº‹ä»¶é¢„æµ‹å®¹å™¨
            const eventArea = document.createElement('div');
            eventArea.className = 'event-prediction-area';
            eventArea.innerHTML = `
                <div class="section-title">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>äº‹ä»¶é¢„æµ‹</span>
                </div>
                <div id="event-prediction-container" class="prediction-container">
                    <div class="no-predictions">æš‚æ— å¼‚å¸¸äº‹ä»¶é¢„æµ‹</div>
                </div>
            `;
            
            // å°†äº‹ä»¶é¢„æµ‹åŒºåŸŸæ’å…¥åˆ°ä¸»å†…å®¹åŒºåŸŸçš„æœ€å‰é¢
            mainContent.insertBefore(eventArea, mainContent.firstChild);
            
            // æ·»åŠ äº‹ä»¶é¢„æµ‹ç›¸å…³çš„CSS
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .event-prediction-area {
                    margin-bottom: 20px;
                    background-color: #fff;
                    border-radius: 8px;
                    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                    padding: 15px;
                }
                
                .prediction-container {
                    margin-top: 10px;
                }
                
                .no-predictions {
                    color: #888;
                    text-align: center;
                    padding: 10px;
                }
                
                .event-prediction-card {
                    padding: 12px;
                    border-radius: 6px;
                    margin-bottom: 10px;
                    border-left: 4px solid #5cb85c;
                    background-color: #f9f9f9;
                }
                
                .event-prediction-card.severity-high {
                    border-left-color: #d9534f;
                }
                
                .event-prediction-card.severity-medium {
                    border-left-color: #f0ad4e;
                }
                
                .event-prediction-card.severity-low {
                    border-left-color: #5bc0de;
                }
                
                .event-header {
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                }
                
                .event-type {
                    font-weight: bold;
                    font-size: 16px;
                }
                
                .event-probability {
                    font-weight: bold;
                    color: #d9534f;
                }
                
                .event-reasoning {
                    margin-bottom: 10px;
                    line-height: 1.4;
                }
                
                .event-details {
                    display: flex;
                    flex-direction: column;
                    font-size: 12px;
                    color: #777;
                }
                
                .event-timestamp, .event-sensors {
                    margin-bottom: 2px;
                }
            `;
            document.head.appendChild(styleElement);
        }

        // åˆå§‹åŒ–äº‹ä»¶é¢„æµ‹æ•°æ®
        let eventPredictions = []; 

        // æ·»åŠ æ‘„åƒå¤´æ ·å¼
        addCameraStyles();

        // æ·»åŠ äº‹ä»¶é¢„æµ‹æ ·å¼
        function addEventPredictionStyles() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .event-predictions-section {
                    margin-top: 10px;
                }
                
                .no-predictions {
                    color: #888;
                    text-align: center;
                    padding: 10px;
                }
                
                .event-prediction-card {
                    padding: 12px;
                    border-radius: 6px;
                    margin-bottom: 10px;
                    border-left: 4px solid #5cb85c;
                    background-color: #f9f9f9;
                }
                
                .event-prediction-card.severity-high {
                    border-left-color: #d9534f;
                }
                
                .event-prediction-card.severity-medium {
                    border-left-color: #f0ad4e;
                }
                
                .event-prediction-card.severity-low {
                    border-left-color: #5bc0de;
                }
                
                .event-header {
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                }
                
                .event-type {
                    font-weight: bold;
                    font-size: 16px;
                }
                
                .event-probability {
                    font-weight: bold;
                    color: #d9534f;
                }
                
                .event-reasoning {
                    margin-bottom: 10px;
                    line-height: 1.4;
                }
                
                .event-details {
                    display: flex;
                    flex-direction: column;
                    font-size: 12px;
                    color: #777;
                }
                
                .event-timestamp, .event-sensors {
                    margin-bottom: 2px;
                }
            `;
            document.head.appendChild(styleElement);
        }

        // æ·»åŠ æ‘„åƒå¤´æ ·å¼
        addCameraStyles();
    </script>
</body>
</html> 